#pragma once
#include "../../../SFC/essentials.h"

#ifndef RVM_HASH_SIZE
#define RVM_HASH_SIZE		(32U)
#endif

namespace rvm
{
#pragma pack(push, 1)

enum class SecSuite: uint8_t
{
	Unknown = 0,

	Cryptography = 1,			// address is a public key, signing by private key
	Ethereum = Cryptography,	// ethereum
	Reserved1,					// 
	Ed25519,					// default
	CryptographyMax,

	NoSigning = 4,				// address is not sign-able at all
	Contract = NoSigning,		// it's a contract, converted from the contract's id
	Custom,						// some address procedurally generated by code
	NoSigningMax,

	Delegated	= 8,			// address is not based on a public key, signing is delegated to a address of Cryptography type
	DelegatedAsHash = Delegated,
	DelegatedAsName,
	DelegatedAsDApp,
	DelegatedAsToken,
	DelegatedMax,
			
	None = 0xff
};

static_assert(uint8_t(SecSuite::CryptographyMax) <= uint8_t(SecSuite::NoSigning), "CryptographyMax section overlaps with NoSigning section");
static_assert(uint8_t(SecSuite::NoSigningMax) <= uint8_t(SecSuite::Delegated), "NoSigningMax section overlaps with Delegated section");

typedef uint32_t UInt32;
typedef uint64_t UInt64;
struct UInt96  { union{ struct { UInt64		a;	UInt32  e;	}; uint8_t _[12]; }; };
struct UInt128 { union{ struct { UInt64		a;	UInt64  e;	}; uint8_t _[16]; }; };
struct UInt160 { union{ struct { UInt128	a;	UInt32  e;	}; uint8_t _[20]; }; };
struct UInt256 { union{ struct { UInt128	a;	UInt128	e;	}; uint8_t _[32]; }; };
struct UInt512 { union{ struct { UInt256	a;	UInt256	e;	}; uint8_t _[64]; }; };
static_assert(sizeof(UInt96)  == 12);
static_assert(sizeof(UInt128) == 16);
static_assert(sizeof(UInt160) == 20);
static_assert(sizeof(UInt256) == 32);
static_assert(sizeof(UInt512) == 64);

struct Address
{	
	union {
	UInt256		a;
	uint8_t		_[RVM_HASH_SIZE];
	};
	union {
	uint32_t	_SSID:4;
	uint32_t	_CheckSum;
	uint32_t	e;
	};
};
typedef const Address ConstAddress;
static_assert(sizeof(Address) == 36);

struct UInt336 { union{ struct { Address	a;	UInt64	e;	}; uint8_t _[44]; }; };
static_assert(sizeof(UInt336) == 44);


// 6-bit
enum class ScopeKeySized : uint8_t
{
	// non-Enumerable
	Default = 0,	// actual scope is defined on scope_slot
	Address = 0,	// address/36B (slot #0, #1, #2 were occupied for ScopeType::Contract, slot for customized address scope should starts from #3)
	UInt32,			// uint32_t	: 4B
	UInt64,			// uint64_t	: 8B
	UInt96,			// uint96_t	: 12B
	UInt128,		// SHA128	: 16B
	UInt160,		// SHA160	: 20B
	UInt256,		// SHA256	: 32B
	UInt512,		// SHA512	: 64B
	UInt336,		// <Address,UInt64>	: 42B
	// Enumerable
	AddressEnumerable = 0x20,	// address
	UInt32Enumerable,			// uint32_t
	UInt64Enumerable,			// uint64_t
	UInt96Enumerable,			// uint96_t
	UInt128Enumerable,			// MD5/uint128_t
	UInt160Enumerable,			// SHA160		
	UInt256Enumerable,			// SHA256		
	UInt512Enumerable,			// SHA512
	UInt336Enumerable,			// <Address,UInt64>	

	Bitmask = 0x3fu,
	BaseTypeBitmask = 0x1fu,
	IsEnumerable = 0x20u
};

static const ScopeKeySized ScopeKeySizeInvalid = ScopeKeySized::Bitmask;

struct ScopeKey
{
	const uint8_t*	Data;
	uint32_t		Size;
};

template<int SZ>
inline constexpr uint32_t	SCOPEKEY_SHARD_DWORD(const uint8_t* p)
							{	const uint32_t* d = (const uint32_t*)p;
								if		constexpr (SZ == 1)return *(uint8_t*)d;
								else if constexpr (SZ == 2)return *(uint16_t*)d;
								else if constexpr (SZ == 3)return (*(uint32_t*)d) & 0xffffffU;
								else if constexpr (SZ == 4)return *d;
								else if constexpr (SZ == 36)return d[0] ^ d[4] ^ d[7]; // TBD: remove when code is stable, was for compatibility of Monoxide
								else return d[0] ^ d[SZ/8] ^ d[SZ/4 - 1];
							}
inline constexpr uint32_t	SCOPEKEY_SHARD_DWORD(const ScopeKey& k)
							{	if(k.Size < 4 || k.Data == nullptr)return 0;
								const uint32_t* d = (const uint32_t*)k.Data;
								if(k.Size == 36)return d[0] ^ d[4] ^ d[7];  // TBD: remove when code is stable, was for compatibility of Monoxide
								return d[0] ^ d[k.Size/8] ^ d[k.Size/4 - 1];
							}
inline uint32_t				SCOPEKEY_SHARD_BITMASK(uint32_t shard_order){ return ~(((uint32_t)(-1))<<shard_order); }
inline uint32_t				SCOPEKEY_SHARD_BRANCH_BIT(uint32_t shard_order){ return shard_order?(1U<<(shard_order-1)):0; } // 0 for base, otherwise for up
inline constexpr int		SCOPEKEY_SIZE(ScopeKeySized t)
							{	switch((ScopeKeySized)(uint16_t(ScopeKeySized::BaseTypeBitmask)& uint16_t(t)))
								{	case ScopeKeySized::UInt32:  return sizeof(UInt32);
									case ScopeKeySized::UInt64:  return sizeof(UInt64);
									case ScopeKeySized::UInt96:  return sizeof(UInt96);
									case ScopeKeySized::UInt128: return sizeof(UInt128);
									case ScopeKeySized::UInt160: return sizeof(UInt160);
									case ScopeKeySized::UInt256: return sizeof(UInt256);
									case ScopeKeySized::Address: return sizeof(Address);
									case ScopeKeySized::UInt336: return sizeof(UInt336);
									case ScopeKeySized::UInt512: return sizeof(UInt512);
									default: return -1;
								}
							}
inline constexpr auto		SCOPEKEYTYPED_BYSIZE(int s)
							{	switch(s)
								{	case 4:  return ScopeKeySized::UInt32;
									case 8:  return ScopeKeySized::UInt64;
									case 12: return ScopeKeySized::UInt96;
									case 16: return ScopeKeySized::UInt128;
									case 20: return ScopeKeySized::UInt160;
									case 32: return ScopeKeySized::UInt256;
									case 36: return ScopeKeySized::Address;
									case 64: return ScopeKeySized::UInt512;
									default: return ScopeKeySizeInvalid;
								}
							}

inline constexpr bool		SCOPEKEYSIZE_SHOULD_REFER(ScopeKeySized t){ return t==ScopeKeySized::Default || ((int)t&(int)ScopeKeySized::BaseTypeBitmask) >= (int)ScopeKeySized::UInt160; }

static const uint32_t		ADDRESS_DWORD_SIZE = sizeof(Address)/sizeof(uint32_t);
static const uint32_t		ADDRESS_BASE32_LEN = (sizeof(Address)*8 + 4)/5; // 58
static const uint32_t		ADDRESS_ABBREVIATION_LEN = 7;  //  xxx:yyy

inline 			 uint32_t	ADDRESS_SHARD_DWORD(const Address& a){ return SCOPEKEY_SHARD_DWORD<sizeof(Address)>((uint8_t*)&a); }
inline constexpr uint32_t	ADDRESS_SHARD_BITMASK(uint32_t shard_order){ return ~(((uint32_t)(-1))<<shard_order); }
inline 			 uint32_t	ADDRESS_SHARD_INDEX(const Address& a, uint32_t shard_order){ return ADDRESS_SHARD_DWORD(a)&ADDRESS_SHARD_BITMASK(shard_order); }
inline constexpr SecSuite	ADDRESS_SECSUITE_ID(const Address& a){ return (SecSuite)(a._SSID); }
inline			 bool		ADDRESS_IS_VALID(const Address& a){ return !(0xfffffff0 & (a._CheckSum ^ os::crc32c(a._, RVM_HASH_SIZE, (uint32_t)ADDRESS_SECSUITE_ID(a)))); }
inline			 void		ADDRESS_SET_SECSUITE(Address& a, SecSuite ssid){ a._CheckSum = ((uint8_t)ssid&0xf) | (0xfffffff0 & os::crc32c(a._, RVM_HASH_SIZE, (uint32_t)ssid)); }


#pragma pack(pop)
} // namespace rvm