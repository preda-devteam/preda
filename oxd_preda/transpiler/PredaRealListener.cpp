#include "PredaRealListener.h"

class AutoPopFunctionContextLocalScopeStack {
public:
	transpiler::FunctionContext *pContext;
	AutoPopFunctionContextLocalScopeStack(transpiler::FunctionContext *inContext)
	{
		pContext = inContext;
	}
	~AutoPopFunctionContextLocalScopeStack()
	{
		if (pContext)
		{
			pContext->PopScope();
		}
	}
};

#define AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK AutoPopFunctionContextLocalScopeStack autoPopFunctionContextLocalScopeStack(&m_transpilerCtx.functionCtx);

class AutoPopThisPtrStack {
public:
	transpiler::ThisPtrStack *pThisPtrStack;
	AutoPopThisPtrStack(transpiler::ThisPtrStack *inStack)
	{
		pThisPtrStack = inStack;
	}
	~AutoPopThisPtrStack()
	{
		if (pThisPtrStack)
		{
			pThisPtrStack->Pop();
		}
	}
};

#define AUTO_POP_THIS_PTR_STACK AutoPopThisPtrStack autoPopThisPtrStack(&m_transpilerCtx.thisPtrStack);

using ConcreteTypePtr = transpiler::ConcreteTypePtr;

transpiler::DefinedIdentifierPtr PredaRealListener::DefineFunctionLocalVariable(ConcreteTypePtr pType, PredaParser::IdentifierContext *identifierCtx, bool bIsConst, uint32_t flags)
{
	m_errorPortal.SetAnchor(identifierCtx->start);
	return DefineFunctionLocalVariable(pType, identifierCtx->getText(), bIsConst, flags);
}

transpiler::DefinedIdentifierPtr PredaRealListener::DefineFunctionLocalVariable(ConcreteTypePtr pType, const std::string &identifierName, bool bIsConst, uint32_t flags)
{
	assert(pType != nullptr);
	assert(m_transpilerCtx.functionCtx.IsInsideFunction());

	if (!m_identifierHub.ValidateNewIdentifier(identifierName))
		return nullptr;

	ConcreteTypePtr outerType = m_transpilerCtx.functionCtx.localScopes.back().concreteType;

	transpiler::DefinedIdentifierPtr ret = outerType->DefineMemberVariable(pType, identifierName, flags, bIsConst, true, false);
	if (ret == nullptr)
	{
		m_errorPortal.AddInternalError("identifier \"" + identifierName + "\" cannot be defined, unknown error");
		return nullptr;
	}

	return ret;
}

static void GenerateCodeForInterfaceFunction(CodeSerializer& codeSerializer, const std::string &interfaceName, const std::string& name, const transpiler::FunctionSignature& functionSignature, uint32_t interfaceFunctionIdx)
{
	{
		std::string line;
		if (functionSignature.returnType.baseConcreteType == nullptr)
		{
			line += "void";
		}
		else
		{
			if (functionSignature.returnType.bIsConst)
				line += "const ";
			line += functionSignature.returnType.baseConcreteType->outputFullName;
		}
		line += " " + name + "(";
		for (size_t j = 0; j < functionSignature.parameters.size(); j++)
		{
			if (j > 0)
				line += ", ";
			// Note: Here always declare trampoline function parameters as const.
			//       User may pass a rvalue to the function, which a non-const lvalue reference cannot be bound to and generates a c++ compile error.
			//       The "const" will be later removed from the argument after passed down the cross-contract call pipeline.
			//if (functionSignature.parameters[i]->qualifiedType.bIsConst)
			line += "const ";
			line += functionSignature.parameters[j]->qualifiedType.baseConcreteType->outputFullName + " &" + functionSignature.parameters[j]->outputName;
		}
		line += ")";
		if ((functionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::IsConst)) != 0)
			line += " const";
		line += " {";
		codeSerializer.AddLine(line);
		codeSerializer.PushIndent();
	}

	{
		std::string line;
		if (functionSignature.returnType.baseConcreteType != nullptr)
			line = "return prlrt::interface_call<" + functionSignature.returnType.baseConcreteType->outputFullName + ">(";
		else
			line = "prlrt::interface_call_no_ret(";
		line += "contract_id, \"" + interfaceName + "\", " + std::to_string(interfaceFunctionIdx);
		for (size_t j = 0; j < functionSignature.parameters.size(); j++)
			line += ", " + functionSignature.parameters[j]->outputName;
		line += ");";
		codeSerializer.AddLine(line);
	}

	{
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
		codeSerializer.AddLine("");
	}
}

ConcreteTypePtr PredaRealListener::ImportContractSymbols(transpiler::IContractSymbols *pContractSymbols, const std::string contractImportName)
{
	size_t contractImportSlot = m_importedContracts.size();

	std::string contractFullName = pContractSymbols->GetDAppName() + std::string(".") + pContractSymbols->GetContractName();

	// Shouldn't call ValidateNewTypeNameIdentifier(contractImportName) here because 
	// 1. It's generated by the compiler and should not have any conflict.
	// 2. Implicitly imported contract are given "__" prefix to avoid name conflict, and will fail the check.
	//if (!ValidateNewTypeNameIdentifier(contractImportName, line, pos))
	//{
	//	return false;
	//}

	ConcreteTypePtr contractType = m_transpilerCtx.globalType->CreateInnerContractType(contractImportName, contractFullName);
	if (contractType == nullptr)
	{
		m_errorPortal.AddInternalError("Cannot declare contract type for imported contract \"" + contractFullName + "\" as \"" + contractImportName + "\". Probably compiler bug.");
		return nullptr;
	}

	m_transpilerCtx.thisPtrStack.Push(contractType, false);
	AUTO_POP_THIS_PTR_STACK;

	codeSerializer.AddLine("struct " + contractType->outputFullName + " {");
	codeSerializer.PushIndent();

	// enums
	{
		uint32_t numEnumTypes = pContractSymbols->GetNumEnumTypes();
		for (uint32_t enumTypeIdx = 0; enumTypeIdx < numEnumTypes; enumTypeIdx++)
		{
			std::string enumTypeName = pContractSymbols->GetEnumTypeName(enumTypeIdx);
			if (!m_identifierHub.ValidateNewIdentifier(enumTypeName))
				return nullptr;
			ConcreteTypePtr enumType = contractType->CreateInnerEnumType(enumTypeName);
			m_transpilerCtx.thisPtrStack.Push(enumType, false);
			AUTO_POP_THIS_PTR_STACK;
			if (enumType == nullptr)
			{
				m_errorPortal.AddInternalError("enum type \"" + enumTypeName + "\" cannot be imported. Unknown error.");
				return nullptr;
			}
			std::string enumTypeOutputName = enumType->outputFullName.substr(enumType->outputFullName.rfind("::") + 2);
			codeSerializer.AddLine("enum class " + enumTypeOutputName + "__ : prlrt::enum_base_type {");
			codeSerializer.PushIndent();
			uint32_t numEnumerators = pContractSymbols->GetNumEnumerators(enumTypeIdx);
			if (numEnumerators > 65535)
			{
				m_errorPortal.AddTooManyEnumeratorsError();
				return nullptr;
			}
			for (uint32_t enumeratorIdx = 0; enumeratorIdx < numEnumerators; enumeratorIdx++)
			{
				if (!m_identifierHub.ValidateNewIdentifier(pContractSymbols->GetEnumerator(enumTypeIdx, enumeratorIdx)))
					return nullptr;
				transpiler::DefinedIdentifierPtr pEnumerator = enumType->DefineMemberVariable(enumType, pContractSymbols->GetEnumerator(enumTypeIdx, enumeratorIdx), 0, true, false, true);
				if (pEnumerator == nullptr)
					return nullptr;
				codeSerializer.AddLine(pEnumerator->outputName + " = " + std::to_string(enumeratorIdx) + (enumeratorIdx != numEnumerators - 1 ? "," : ""));
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("};");
			codeSerializer.AddLine("using " + enumTypeOutputName + " = prlrt::enum_wrapper<" + enumTypeOutputName + "__, " + std::to_string(numEnumerators) + ">;");
			codeSerializer.AddLine("");
		}
	}

	// structs
	{
		uint32_t numStructTypes = pContractSymbols->GetNumStructTypes();
		for (uint32_t structTypeIdx = 0; structTypeIdx < numStructTypes; structTypeIdx++)
		{
			std::string structTypeName = pContractSymbols->GetStructTypeName(structTypeIdx);
			if (!m_identifierHub.ValidateNewIdentifier(structTypeName))
				return nullptr;

			uint32_t numMembers = pContractSymbols->GetNumStructMembers(structTypeIdx);
			std::vector<ConcreteTypePtr> vMemberTypes;
			for (uint32_t memberIdx = 0; memberIdx < numMembers; memberIdx++)
			{
				std::string memberType = pContractSymbols->GetStructMemberType(structTypeIdx, memberIdx);
				vMemberTypes.push_back(GetTypeFromExportedTypeName(memberType.c_str()));
			}

			ConcreteTypePtr structType = contractType->CreateInnerUserDefinedStructType(structTypeName);
			if (structType == nullptr)
			{
				m_errorPortal.AddInternalError("struct type \"" + structTypeName + "\" cannot be imported. Unknown error.");
				return nullptr;
			}

			codeSerializer.AddLine("#define EXPAND_STRUCT_MEMBER_LIST\\");
			codeSerializer.PushIndent();

			transpiler::FunctionSignature constructorSignature;
			constructorSignature.returnType = transpiler::QualifiedConcreteType(structType, false, false);		// struct constructor returns a non-lvalue non-const instance
			constructorSignature.flags = uint32_t(transpiler::PredaFunctionFlags::IsConst);
			// Default constructor with no parameters
			{
				bool res = structType->DefineMemberFunction("@constructor", constructorSignature, false) != nullptr;
				assert(res);
			}

			std::vector<std::string> vMemberTypeOutputName(numMembers);
			std::vector<std::string> vMemberOutputName(numMembers);
			for (uint32_t memberIdx = 0; memberIdx < numMembers; memberIdx++)
			{
				std::string memberName = pContractSymbols->GetStructMemberName(structTypeIdx, memberIdx);

				ConcreteTypePtr pType = vMemberTypes[memberIdx];
				if (pType == nullptr)
					return nullptr;
				transpiler::DefinedIdentifierPtr pMember = structType->DefineMemberVariable(pType, memberName, 0, false, true, false);
				if (pMember == nullptr)
					return nullptr;

				constructorSignature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(pType, true, true, memberName, 0));
				vMemberOutputName[memberIdx] = pMember->outputName;
				vMemberTypeOutputName[memberIdx] = pType->outputFullName;

				if (memberIdx > 0)
					codeSerializer.AddLine("SPLITTER\\");
				codeSerializer.AddLine("EXPAND_STRUCT_MEMBER((" + vMemberTypeOutputName[memberIdx] + "), " + vMemberOutputName[memberIdx] + ")" + (memberIdx < numMembers - 1 ? "\\" : ""));
			}

			if (numMembers > 0)
			{
				bool res = structType->DefineMemberFunction("@constructor", constructorSignature, false) != nullptr;
				assert(res);
			}

			codeSerializer.PopIndent();

			std::string structTypeOutputName = structType->outputFullName.substr(structType->outputFullName.rfind("::") + 2);

			codeSerializer.AddLine("#define STRUCT_MEMBER_COUNT " + std::to_string(numMembers));
			codeSerializer.AddLine("#define STRUCT_INTERNAL_NAME " + structTypeOutputName + "__");
			codeSerializer.AddLine("#define STRUCT_NAME " + structTypeOutputName);
			codeSerializer.AddLine("#include \"include/define_struct.h\"");
			codeSerializer.AddLine("");
		}
	}

	// interfaces
	{
		uint32_t numInterfaces = pContractSymbols->GetNumExportedInterfaces();
		for (uint32_t interfaceIdx = 0; interfaceIdx < numInterfaces; interfaceIdx++)
		{
			std::string interfaceName = pContractSymbols->GetExportedInterfaceName(interfaceIdx);
			if (!m_identifierHub.ValidateNewIdentifier(interfaceName))
				return nullptr;
			ConcreteTypePtr interfaceType = contractType->CreateInnerInterfaceType(interfaceName);

			{
				transpiler::FunctionSignature signature;

				//function return type
				signature.returnType = transpiler::QualifiedConcreteType(interfaceType, true, false);		// struct constructor returns a non-lvalue const instance

				signature.flags = uint32_t(transpiler::PredaFunctionFlags::IsConst);

				// constructor with uint64 contract id
				signature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, true, "contract_id", 0));
				bool res = interfaceType->DefineMemberFunction("@constructor", signature, false) != nullptr;
				assert(res);
			}

			codeSerializer.AddLine("struct " + interfaceType->outputFullName.substr(interfaceType->outputFullName.rfind("::") + 2) + " : public prlrt::interface_struct {");
			codeSerializer.PushIndent();
			codeSerializer.AddLine("INTERFACE_INHERIT");

			uint32_t numFunctions = pContractSymbols->GetNumExportedInterfaceFunctions(interfaceIdx);
			for (uint32_t functionIdx = 0; functionIdx < numFunctions; functionIdx++)
			{
				std::string functionName = pContractSymbols->GetExportedInterfaceFunctionName(interfaceIdx, functionIdx);
				m_transpilerCtx.functionCtx.PushFunctionScope(interfaceType->CreateInnerUnnamedScopeType("interface_function_declare_" + functionName));
				AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

				transpiler::FunctionSignature functionSignature;
				functionSignature.flags = pContractSymbols->GetExportedInterfaceFunctionFlag(interfaceIdx, functionIdx);

				uint32_t numParams = pContractSymbols->GetExportedInterfaceFunctionNumParameters(interfaceIdx, functionIdx);
				for (uint32_t paramIdx = 0; paramIdx < numParams; paramIdx++)
				{
					std::string paramType = pContractSymbols->GetExportedInterfaceFunctionParameterType(interfaceIdx, functionIdx, paramIdx);
					std::string paramName = pContractSymbols->GetExportedInterfaceFunctionParameterName(interfaceIdx, functionIdx, paramIdx);
					ConcreteTypePtr pType;
					bool bIsConst = false;
					if (paramType.length() >= 2 && paramType[0] == 'c' && paramType[1] == ' ')
					{
						pType = GetTypeFromExportedTypeName(paramType.c_str() + 2);
						bIsConst = true;
					}
					else
						pType = GetTypeFromExportedTypeName(paramType.c_str());
					if (pType == nullptr)
						return nullptr;
					if (DefineFunctionLocalVariable(pType, paramName, bIsConst, 0) == nullptr)
						return nullptr;
				}
				functionSignature.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

				{
					std::string returnType = pContractSymbols->GetExportedInterfaceFunctionReturnType(interfaceIdx, functionIdx);
					ConcreteTypePtr pType;
					bool bIsConst = false;
					if (returnType != "")
					{
						if (returnType.length() >= 2 && returnType[0] == 'c' && returnType[1] == ' ')
						{
							pType = GetTypeFromExportedTypeName(returnType.c_str() + 2);
							bIsConst = true;
						}
						else
							pType = GetTypeFromExportedTypeName(returnType.c_str());
						if (pType == nullptr)
							return nullptr;
					}
					else
						bIsConst = true;
					functionSignature.returnType = transpiler::QualifiedConcreteType(pType, bIsConst, false);
				}

				transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->DefineMemberFunction(functionName, functionSignature, false);
				if (pDefinedFunction == nullptr)
					return nullptr;

				GenerateCodeForInterfaceFunction(codeSerializer, interfaceType->exportName, pDefinedFunction->outputName, functionSignature, functionIdx);
			}

			codeSerializer.PopIndent();
			codeSerializer.AddLine("};");
		}
	}

	// functions
	{
		uint32_t numExportedFunctions = pContractSymbols->GetNumExportedFunctions();
		for (uint32_t functionIdx = 0; functionIdx < numExportedFunctions; functionIdx++)
		{
			uint32_t flags = pContractSymbols->GetExportedFunctionFlag(functionIdx);
			if ((flags & (uint32_t(transpiler::PredaFunctionFlags::CallableFromOtherContract))) == 0)
				continue;

			std::string functionName = pContractSymbols->GetExportedFunctionName(functionIdx);

			assert(m_transpilerCtx.functionCtx.localScopes.size() == 0);
			m_transpilerCtx.functionCtx.localScopes.push_back(transpiler::FunctionContext::LocalScope(transpiler::FunctionContext::LocalScope::Scope_Function, contractType->CreateInnerUnnamedScopeType("function_" + functionName)));
			AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

			transpiler::FunctionSignature functionSignature;
			functionSignature.flags = flags;

			{
				ConcreteTypePtr type;
				transpiler::DefinedIdentifierPtr pIdentifier;
				if (m_identifierHub.FindExistingIdentifier(functionName, &type, &pIdentifier))
				{
					// not an overloaded function in the same scope
					if (!(pIdentifier != nullptr && pIdentifier->qualifiedType.baseConcreteType->outerType == contractType && pIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType))
						return nullptr;
				}
			}

			uint32_t numParams = pContractSymbols->GetExportedFunctionNumParameters(functionIdx);
			for (uint32_t paramIdx = 0; paramIdx < numParams; paramIdx++)
			{
				std::string paramType = pContractSymbols->GetExportedFunctionParameterType(functionIdx, paramIdx);
				std::string paramName = pContractSymbols->GetExportedFunctionParameterName(functionIdx, paramIdx);
				ConcreteTypePtr pType;
				bool bIsConst = false;
				if (paramType.length() >= 2 && paramType[0] == 'c' && paramType[1] == ' ')
				{
					pType = GetTypeFromExportedTypeName(paramType.c_str() + 2);
					bIsConst = true;
				}
				else
					pType = GetTypeFromExportedTypeName(paramType.c_str());
				if (pType == nullptr)
					return nullptr;
				if (DefineFunctionLocalVariable(pType, paramName, bIsConst, 0) == nullptr)
					return nullptr;
			}
			functionSignature.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

			{
				std::string returnType = pContractSymbols->GetExportedFunctionReturnType(functionIdx);
				ConcreteTypePtr pType;
				bool bIsConst = false;
				if (returnType != "")
				{
					if (returnType.length() >= 2 && returnType[0] == 'c' && returnType[1] == ' ')
					{
						pType = GetTypeFromExportedTypeName(returnType.c_str() + 2);
						bIsConst = true;
					}
					else
						pType = GetTypeFromExportedTypeName(returnType.c_str());
					if (pType == nullptr)
						return nullptr;
				}
				functionSignature.returnType = transpiler::QualifiedConcreteType(pType, bIsConst, false);
			}

			
			transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction(functionName, functionSignature, true);
			if (pDefinedFunction == nullptr)
				return nullptr;

			{
				std::string line = "static ";		// functions in imported contracts are all static
				if (functionSignature.returnType.baseConcreteType == nullptr)
				{
					line += "void";
				}
				else
				{
					if (functionSignature.returnType.bIsConst)
						line += "const ";
					line += functionSignature.returnType.baseConcreteType->outputFullName;
				}
				line += " " + pDefinedFunction->outputName + "(";
				for (size_t i = 0; i < functionSignature.parameters.size(); i++)
				{
					if (i > 0)
						line += ", ";
					// Note: Here always declare trampoline function parameters as const.
					//       User may pass a rvalue to the function, which a non-const lvalue reference cannot be bound to and generates a c++ compile error.
					//       The "const" will be later removed from the argument after passed down the cross-contract call pipeline.
					//if (functionSignature.parameters[i]->qualifiedType.bIsConst)
						line += "const ";
					line += functionSignature.parameters[i]->qualifiedType.baseConcreteType->outputFullName + " &" + functionSignature.parameters[i]->outputName;
				}
				line += ") {";
				codeSerializer.AddLine(line);
				codeSerializer.PushIndent();
			}

			{
				std::string line;
				if (functionSignature.returnType.baseConcreteType != nullptr)
					line = "return prlrt::cross_call<" + functionSignature.returnType.baseConcreteType->outputFullName + ">(";
				else
					line = "prlrt::cross_call_no_ret(";
				line += "__prli___imported_contract_ids[" + std::to_string(contractImportSlot) + "], " + std::to_string(functionIdx);
				for (size_t i = 0; i < functionSignature.parameters.size(); i++)
					line += ", " + functionSignature.parameters[i]->outputName;
				line += ");";
				codeSerializer.AddLine(line);
			}

			{
				codeSerializer.PopIndent();
				codeSerializer.AddLine("}");
				codeSerializer.AddLine("");
			}
		}
	}

	// __id()
	transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__id", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::PredaFunctionFlags::IsConst)
		), true);
	if (pDefinedFunction == nullptr)
		return nullptr;
	codeSerializer.AddLine("static " + m_transpilerCtx.GetBuiltInIntegerType(64, false)->outputFullName + " __prli___id() { return __prli___imported_contract_ids[" + std::to_string(contractImportSlot) + "]; }");

	// constructor and ::__self() is no longer needed as now imported contracts are not instantiated any more, their function are accessed as static functions
	//// constructor
	//codeSerializer.AddLine(contractType->outputFullName + "() {}");

	//// __self()
	//transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__self", transpiler::FunctionSignature(
	//		transpiler::QualifiedConcreteType(contractType, true, false),
	//		std::vector<transpiler::DefinedIdentifierPtr>(),
	//		uint32_t(transpiler::PredaFunctionFlags::IsConst)
	//	), true);
	//if (pDefinedFunction == nullptr)
	//	return nullptr;
	//// TODO: currently we don't support getting contract instances from other addresses. Hence __self could not the default constructor.
	////       in the future, this needs to be initialized with _transactions.get_self_address() to differentiate from other instances.
	//codeSerializer.AddLine("static " + contractType->outputFullName + " __prli___self() { return " + contractType->outputFullName + "(); }");

	codeSerializer.PopIndent();
	codeSerializer.AddLine("};");
	codeSerializer.AddLine("");
	return contractType;
}

bool PredaRealListener::ImportContract(const std::string &contractFullName)
{
	//already imported
	if (std::find(m_importedContracts.begin(), m_importedContracts.end(), contractFullName) != m_importedContracts.end())
		return true;
	//already failed import once
	if (m_failedImportContracts.find(contractFullName) != m_failedImportContracts.end())
		return false;

	transpiler::IContractSymbols *pContractSymbols = m_pContractSymbolDatabase->GetContractSymbols(contractFullName.c_str());
	if (pContractSymbols == nullptr)
	{
		m_failedImportContracts.emplace(contractFullName);
		return false;
	}

	uint32_t numImportedContracts = pContractSymbols->GetNumImportedContracts();
	for (uint32_t i = 0; i < numImportedContracts; i++)
	{
		std::string indirectlyImportedContractFullName = pContractSymbols->GetImportedContractFullName(i);
		if (!ImportContract(indirectlyImportedContractFullName))
		{
			m_failedImportContracts.emplace(contractFullName);
			return false;
		}
	}

	std::string importName = "__imported_" + std::to_string(m_importedContracts.size()) + "_" + pContractSymbols->GetDAppName() + std::string("_") + pContractSymbols->GetContractName();

	// This has to be assigned before 
	{
		bool res = m_contractFullNameToImportName.try_emplace(contractFullName, importName).second;
		assert(res);
	}

	ConcreteTypePtr importedContractType = ImportContractSymbols(pContractSymbols, importName);
	if (importedContractType == nullptr)
	{
		m_failedImportContracts.emplace(contractFullName);
		return false;
	}

	m_importedContracts.push_back(contractFullName);
	{
		bool res = m_importedContractsType.try_emplace(contractFullName, importedContractType).second;
		assert(res);
	}

	return true;
}

void PredaRealListener::ProcessImportDirective(const PredaParser::ImportDirectiveContext *ctx)
{
	std::string contractFullName;
	if (ctx->dAppName)
		contractFullName = ctx->dAppName->getText() + "." + ctx->contractName->getText();
	else
		contractFullName = m_currentDAppName + "." + ctx->contractName->getText();

	if (!ImportContract(contractFullName))
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddContractImportFailure(contractFullName);
		return;
	}
}

void PredaRealListener::ProcessDirectives(const std::vector<PredaParser::DirectiveContext *> &vDirectiveCtx)
{
	codeSerializer.AddLine("static uint64_t __prli___cur_contract_id = 0;");
	codeSerializer.AddLine("static uint64_t *__prli___imported_contract_ids = nullptr;");

	for (auto it : vDirectiveCtx)
	{
		if (it->importDirective())
			ProcessImportDirective(it->importDirective());
		else
			assert(0);
	}

	for (auto it : vDirectiveCtx)
	{
		if (it->importDirective())
		{
			PredaParser::ImportDirectiveContext *ctx = it->importDirective();
			PredaParser::IdentifierContext *aliasCtx = ctx->alias != nullptr ? ctx->alias : ctx->contractName;
			std::string alias = aliasCtx->getText();
			if (!m_identifierHub.ValidateNewIdentifier(aliasCtx))
				continue;

			std::string contractFullName;
			if (ctx->dAppName)
				contractFullName = ctx->dAppName->getText() + "." + ctx->contractName->getText();
			else
				contractFullName = m_currentDAppName + "." + ctx->contractName->getText();

			if (m_importedContractsType.find(contractFullName) == m_importedContractsType.end())
				continue;

			if (m_transpilerCtx.globalType->CreateInnerAliasType(alias, m_importedContractsType[contractFullName]) == nullptr)
			{
				m_errorPortal.AddInternalError(aliasCtx->start, "Cannot create alias for imported contract. Probably a compiler error");
				continue;
			}
		}
		else
		{
			assert(0);
		}
	}
}

void PredaRealListener::enterPredaSource(PredaParser::PredaSourceContext *ctx)
{
	m_currentContractName = ctx->contractDefinition()->identifier()->getText();

	m_currentContractUniqueIdentifierStr = m_currentDAppName + "_" + m_currentContractName + "_" + std::to_string(m_currentDAppName.size());
	m_currentContractNamespace = "NS_" + m_currentContractUniqueIdentifierStr;

	codeSerializer.AddLine("namespace " + m_currentContractNamespace + " {");

	ProcessDirectives(ctx->directive());
	if (m_errorPortal.m_errors.size() > 0)
	{
		m_pWalker->SkipCurrentRuleSubtree();
		return;
	}
}

bool PredaRealListener::ProcessLocalVariableDeclaration(PredaParser::LocalVariableDeclarationContext *ctx, std::string &outRes)
{
	ConcreteTypePtr varType;

	if (ctx->typeNameOrAuto()->typeName())
	{
		varType = m_identifierHub.GetTypeFromTypeNameContext(ctx->typeNameOrAuto()->typeName());
		if (varType == nullptr)
			return false;
	}

	bool bIsConst = ctx->typeNameOrAuto()->ConstantKeyword() != nullptr;
	ExpressionParser::ExpressionResult expRes;
	if (ctx->expression())
	{
		if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
			return false;

		if (ctx->typeNameOrAuto()->AutoKeyword())
		{
			varType = expRes.type.baseConcreteType;
			if (expRes.type.bIsConst && expRes.type.baseConcreteType->IsConstTransitive())
				bIsConst = true;
		}
		else
		{
			if (varType != expRes.type.baseConcreteType)
			{
				std::tuple<transpiler::OperatorTypeBitMask, ConcreteTypePtr, ConcreteTypePtr> k = std::make_tuple(transpiler::OperatorTypeBitMask::AssignmentBit, varType, expRes.type.baseConcreteType);
				auto iter = m_transpilerCtx.opProcessor.m.find(k);
				if (iter != m_transpilerCtx.opProcessor.m.end())
				{
					expRes.text = varType->outputFullName + "(" + expRes.text + ")";
				}
				else
				{
					m_errorPortal.SetAnchor(((antlr4::tree::TerminalNode*)ctx->children[2])->getSymbol());
					m_errorPortal.AddTypeMismatchError(varType, expRes.type.baseConcreteType);
					return false;
				}
			}

			if (expRes.type.baseConcreteType->IsConstTransitive() && expRes.type.bIsConst && !bIsConst)
			{
				m_errorPortal.SetAnchor(((antlr4::tree::TerminalNode*)ctx->children[2])->getSymbol());
				m_errorPortal.AddAssignConstReferenceTypeToNonConstError(expRes.type.baseConcreteType);
				return false;
			}
		}
	}
	else
	{
		if (varType == nullptr)		// auto
		{
			m_errorPortal.SetAnchor(ctx->typeNameOrAuto()->start);
			m_errorPortal.AddAutoDeclarationWithoutInitializerError();
			return false;
		}
	}

	if (varType->typeCategory == transpiler::ConcreteType::ContractType)
	{
		m_errorPortal.SetAnchor(ctx->typeNameOrAuto()->start);
		m_errorPortal.AddIllegalUseOfContractTypeError();
	}

	transpiler::DefinedIdentifierPtr pDefinedVariable = DefineFunctionLocalVariable(varType, ctx->identifier(), bIsConst, 0);
	if (pDefinedVariable == nullptr)
		return false;

	outRes = pDefinedVariable->qualifiedType.baseConcreteType->outputFullName + " " + pDefinedVariable->outputName;
	if (ctx->expression())
		outRes += " = " + expRes.text;
	
	return true;
}
std::string PredaRealListener::ProcessDoxygen(PredaParser::DoxygenContext *ctx){
	if(ctx->DoxygenSingle().size() > 0){
		std::string singleLine;
		for(int i = 0; i < ctx->DoxygenSingle().size(); i++){
			singleLine += ctx->DoxygenSingle(i)->getText();
		}
		return singleLine;
	}
	return ctx->DoxygenMulti()->getText();

}
void PredaRealListener::enterDoxygen(PredaParser::DoxygenContext *ctx){
}
void PredaRealListener::enterVariableDeclarationStatement(PredaParser::VariableDeclarationStatementContext *ctx)
{
	std::string line;
	if (ProcessLocalVariableDeclaration(ctx->localVariableDeclaration(), line))
	{
		line += ";";
		codeSerializer.AddLine(line);
	}
}

void PredaRealListener::enterExpressionStatement(PredaParser::ExpressionStatementContext *ctx)
{
	ExpressionParser::ExpressionResult expRes;
	if (m_expressionParser.ParseExpression(ctx->expression(), expRes))
	{
		codeSerializer.AddLine(expRes.text + ";");
	}
}

void PredaRealListener::enterReturnStatement(PredaParser::ReturnStatementContext *ctx)
{
	if (!m_transpilerCtx.functionCtx.IsInsideFunction())
		return;

	transpiler::FunctionSignature *pSignature = m_transpilerCtx.functionCtx.GetFunctionSignature();

	if (!pSignature)
		return;

	if (pSignature->returnType.baseConcreteType == nullptr)
	{
		if (ctx->expression())
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddReturnValueFromFunctionWithoutReturnTypeError();
			return;
		}
		else
		{
			codeSerializer.AddLine("return;");
			return;
		}
	}
	else
	{
		if (!ctx->expression())
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddReturnWithoutValueFromFunctionWithReturnTypeError(pSignature->returnType.baseConcreteType);
			return;
		}

		ExpressionParser::ExpressionResult expRes;
		if (m_expressionParser.ParseExpression(ctx->expression(), expRes))
		{
			if (expRes.type.baseConcreteType != pSignature->returnType.baseConcreteType)
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddTypeMismatchError(pSignature->returnType.baseConcreteType, expRes.type.baseConcreteType);
				return;
			}
			if (!pSignature->returnType.bIsConst && expRes.type.bIsConst && expRes.type.baseConcreteType->IsConstTransitive())
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddAssignConstReferenceTypeToNonConstError(expRes.type.baseConcreteType);
				return;
			}
			codeSerializer.AddLine("return " + expRes.text + ";");
		}
	}
}

void PredaRealListener::enterIfWithBlock(PredaParser::IfWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_If, "if");

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.AddLine("if (" + expRes.text + ") {");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitIfWithBlock(PredaParser::IfWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PopScope();

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterElseWithBlock(PredaParser::ElseWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_Else, "else");

	codeSerializer.AddLine("else {");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitElseWithBlock(PredaParser::ElseWithBlockContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterElseIfWithBlock(PredaParser::ElseIfWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_ElseIf, "elseif");

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.AddLine("else if (" + expRes.text + ") {");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitElseIfWithBlock(PredaParser::ElseIfWithBlockContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterWhileStatement(PredaParser::WhileStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_While, "while");

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.AddLine("while (" + expRes.text + ") { prlrt::burn_gas_loop();");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitWhileStatement(PredaParser::WhileStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterDoWhileStatement(PredaParser::DoWhileStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_DoWhile, "dowhile");

	codeSerializer.AddLine("do { prlrt::burn_gas_loop();");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitDoWhileStatement(PredaParser::DoWhileStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.PopIndent();
	codeSerializer.AddLine("} while (" + expRes.text + ");");
}

void PredaRealListener::enterForStatement(PredaParser::ForStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_For, "for");

	std::string codeOutput = "for (";

	//statement 1, either a variable declaration or expression
	if (ctx->localVariableDeclaration())
	{
		std::string res;
		if (!ProcessLocalVariableDeclaration(ctx->localVariableDeclaration(), res))
			return;

		codeOutput += res;
	}
	else if (ctx->firstExpression)
	{
		ExpressionParser::ExpressionResult expRes;
		if (!m_expressionParser.ParseExpression(ctx->firstExpression, expRes))
			return;
		codeOutput += expRes.text;
	}
	codeOutput += ";";

	// statement 2, an expression
	if (ctx->secondExpression)
	{
		ExpressionParser::ExpressionResult expRes;
		if (!m_expressionParser.ParseExpression(ctx->secondExpression, expRes))
			return;
		if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
		{
			m_errorPortal.SetAnchor(ctx->secondExpression->start);
			m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		}
		codeOutput += " " + expRes.text;
	}
	codeOutput += ";";

	// statement 3, an expression
	if (ctx->thirdExpression)
	{
		ExpressionParser::ExpressionResult expRes;
		if (!m_expressionParser.ParseExpression(ctx->thirdExpression, expRes))
			return;

		codeOutput += " " + expRes.text;
	}

	codeOutput += ") { prlrt::burn_gas_loop();";

	codeSerializer.AddLine(codeOutput);
	codeSerializer.PushIndent();
}

void PredaRealListener::exitForStatement(PredaParser::ForStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterUserBlockStatement(PredaParser::UserBlockStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_UserBlock, "userblock");

	codeSerializer.AddLine("{");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitUserBlockStatement(PredaParser::UserBlockStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterRelayStatement(PredaParser::RelayStatementContext *ctx)
{
	if (ctx->relayLambdaDefinition())
		m_pWalker->SkipCurrentRuleSubtree();

	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;
	assert(thisType != nullptr && thisType->typeCategory == transpiler::ConcreteType::ContractType);
	if (thisType == nullptr || thisType->typeCategory != transpiler::ConcreteType::ContractType || m_transpilerCtx.functionCtx.GetFunctionSignature() == nullptr)
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddInternalError(ctx->start, "relay / issue statement not available outside a contract function. Probably a compiler bug.");
		return;
	}

	RelayType relayType;

	ExpressionParser::ExpressionResult addrExpRes;
	if (ctx->relayType()->expression())
	{
		if (!m_expressionParser.ParseExpression(ctx->relayType()->expression(), addrExpRes))
			return;

		m_transpilerCtx.functionCtx.GetFunctionSignature()->flags |= uint32_t(transpiler::PredaFunctionFlags::HasRelayAddressStatement);

		if (addrExpRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInAddressType())
		{
			m_errorPortal.SetAnchor(ctx->relayType()->expression()->start);
			m_errorPortal.AddRelayTargetAddressNotAddressTypeError();
			return;
		}

		relayType = RelayType::Address;
	}
	else if (ctx->relayType()->ShardsKeyword())
	{
		m_transpilerCtx.functionCtx.GetFunctionSignature()->flags |= uint32_t(transpiler::PredaFunctionFlags::HasRelayShardsStatement);
		if ((m_transpilerCtx.functionCtx.GetFunctionSignature()->flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) != uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal))
		{
			m_errorPortal.SetAnchor(ctx->relayType()->start);
			m_errorPortal.AddRelayShardsOutsideGlobalError();
			return;
		}
		relayType = RelayType::Shards;
	}
	else if (ctx->relayType()->GlobalKeyword())
	{
		m_transpilerCtx.functionCtx.GetFunctionSignature()->flags |= uint32_t(transpiler::PredaFunctionFlags::HasRelayGlobalStatement);
		if ((m_transpilerCtx.functionCtx.GetFunctionSignature()->flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) == uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal))
		{
			m_errorPortal.SetAnchor(ctx->relayType()->start);
			m_errorPortal.AddRelayGlobalFromGlobalError();
			return;
		}
		relayType = RelayType::Global;
	}
	else
	{
		assert(0);
	}

	int32_t opCode = -1;
	std::string argumentsString;

	if (ctx->relayLambdaDefinition())
	{
		PredaParser::RelayLambdaDefinitionContext *lambdaDefCtx = ctx->relayLambdaDefinition();
		std::vector<PredaParser::RelayLambdaParameterContext*> parameterCtxs = lambdaDefCtx->relayLambdaParameter();

		std::vector<transpiler::QualifiedConcreteType> vParamType(parameterCtxs.size());
		argumentsString = "";
		for (size_t i = 0; i < parameterCtxs.size(); i++)
		{
			PredaParser::TypeNameOrAutoContext *type = parameterCtxs[i]->typeNameOrAuto();

			// type == nullptr means it's a push parameter, i.e. ^identifier
			if (type != nullptr && type->typeName())
			{
				vParamType[i].baseConcreteType = m_identifierHub.GetTypeFromTypeNameContext(type->typeName());
				if (vParamType[i].baseConcreteType == nullptr)
					return;
			}

			vParamType[i].bIsConst = (type != nullptr && type->ConstantKeyword() != nullptr);
			ExpressionParser::ExpressionResult expRes;
			if (type != nullptr)
			{
				if (!m_expressionParser.ParseExpression(parameterCtxs[i]->expression(), expRes))
					return;
			}
			else
			{
				if (!m_expressionParser.ParseIdentifierAsExpression(parameterCtxs[i]->identifier(), expRes))
					return;
			}

			if (type == nullptr || type->AutoKeyword())
			{
				vParamType[i].baseConcreteType = expRes.type.baseConcreteType;
				if (expRes.type.bIsConst && expRes.type.baseConcreteType->IsConstTransitive())
					vParamType[i].bIsConst = true;
			}
			else
			{
				if (vParamType[i].baseConcreteType != expRes.type.baseConcreteType)
				{
					m_errorPortal.SetAnchor(parameterCtxs[i]->expression()->start);
					m_errorPortal.AddTypeMismatchError(vParamType[i].baseConcreteType, expRes.type.baseConcreteType);
					return;
				}
				if (expRes.type.baseConcreteType->IsConstTransitive() && expRes.type.bIsConst && !vParamType[i].bIsConst)
				{
					m_errorPortal.SetAnchor(parameterCtxs[i]->expression()->start);
					m_errorPortal.AddAssignConstReferenceTypeToNonConstError(expRes.type.baseConcreteType);
					return;
				}
			}

			if (vParamType[i].bIsConst && (vParamType[i].baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
			{
				m_errorPortal.SetAnchor(parameterCtxs[i]->identifier()->start);
				m_errorPortal.AddRelayToFunctionWithConstMoveOnlyParamError();
				return;
			}
			if (relayType == RelayType::Shards && (vParamType[i].baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
			{
				m_errorPortal.SetAnchor(parameterCtxs[i]->identifier()->start);
				m_errorPortal.AddRelayShardsToFunctionWithMoveOnlyParamError();
				return;
			}

			argumentsString += ", " + expRes.text;
		}

		opCode = (int32_t)DeclareRelayLambdaFunction(lambdaDefCtx, vParamType, relayType, m_curFunc);
	}
	else
	{
		transpiler::DefinedIdentifierPtr pFunctionIdentifier = thisType->GetMember(ctx->identifier()->getText(), nullptr);
		if (pFunctionIdentifier == nullptr)
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddIdentifierNotDefinedError(ctx->identifier()->getText());
			return;
		}

		if (pFunctionIdentifier->qualifiedType.baseConcreteType->typeCategory != transpiler::ConcreteType::FunctionType)
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddRelayToNoneFunctionError(ctx->identifier()->getText());
			return;
		}

		int overloadFuncIndex = m_expressionParser.FindMatchingOverloadedFunction(pFunctionIdentifier->qualifiedType.baseConcreteType, ctx->functionCallArguments(), argumentsString);
		if (overloadFuncIndex == -1)
			return;
		if (argumentsString.size() != 0)
			argumentsString = ", " + argumentsString;

		transpiler::FunctionSignature &signature = pFunctionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[overloadFuncIndex];
		if (relayType == RelayType::Shards && (signature.flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) != uint32_t(transpiler::PredaFunctionFlags::ContextClassShard))
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddRelayShardsToNonShardFunctionError(ctx->identifier()->getText());
			return;
		}
		if (relayType == RelayType::Global && (signature.flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) != uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal))
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddRelayGlobalToNonGlobalFunctionError(ctx->identifier()->getText());
			return;
		}
		if (relayType == RelayType::Address && (signature.flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) != uint32_t(transpiler::PredaFunctionFlags::ContextClassAddress))
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddRelayAddressToNonAddressFunctionError(ctx->identifier()->getText());
			return;
		}
		for (size_t i = 0; i < signature.parameters.size(); i++)
		{
			const transpiler::DefinedIdentifierPtr &param = signature.parameters[i];
			if ((param->qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0 && param->qualifiedType.bIsConst)
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddRelayToFunctionWithConstMoveOnlyParamError();
				return;
			}
			if (relayType == RelayType::Shards && (param->qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddRelayShardsToFunctionWithMoveOnlyParamError();
				return;
			}
		}
		signature.flags |= uint32_t(transpiler::PredaFunctionFlags::CallableFromRelay);

		transpiler::FunctionRef funcRef;
		funcRef.functionIdentifier = pFunctionIdentifier;
		funcRef.overloadIndex = (size_t)overloadFuncIndex;
		opCode = int32_t(ExportFunction(funcRef));

		if (opCode == -1)
		{
			m_errorPortal.AddInternalError(ctx->start, "relay target \"" + ctx->identifier()->getText() + "\" not exported. Probably a compiler bug.");
			return;
		}
	}

	switch (relayType)
	{
	case RelayType::Address:
		codeSerializer.AddLine("prlrt::relay(" + addrExpRes.text + ", " + std::to_string(opCode) + argumentsString + ");");
		break;
	case RelayType::Shards:
		codeSerializer.AddLine("prlrt::relay_shards(" + std::to_string(opCode) + argumentsString + ");");
		break;
	case RelayType::Global:
		codeSerializer.AddLine("prlrt::relay_global(" + std::to_string(opCode) + argumentsString + ");");
		break;
	default:
		assert(0);
	}
}

size_t PredaRealListener::DeclareRelayLambdaFunction(PredaParser::RelayLambdaDefinitionContext *ctx, const std::vector<transpiler::QualifiedConcreteType> &paramTypes, RelayType type, ForwardDeclaredContractFunction* base)
{
	transpiler::FunctionRef ref;
	m_exportedFunctions.push_back(ref);
	m_pendingRelayLambdas.emplace_back(ctx, paramTypes, type, m_exportedFunctions.size() - 1, base);
	return m_exportedFunctions.size() - 1;
}

void PredaRealListener::enterRelayLambdaDefinition(PredaParser::RelayLambdaDefinitionContext *ctx)
{
}

void PredaRealListener::enterContinueStatement(PredaParser::ContinueStatementContext *ctx)
{
	if (!m_transpilerCtx.functionCtx.IsInsideLoopBlock())
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddContinueOutsideLoopError();
		return;
	}

	codeSerializer.AddLine("continue;");
}

void PredaRealListener::exitContinueStatement(PredaParser::ContinueStatementContext *ctx)
{
}

void PredaRealListener::enterBreakStatement(PredaParser::BreakStatementContext *ctx)
{
	if (!m_transpilerCtx.functionCtx.IsInsideLoopBlock())
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddBreakOutsideLoopError();
		return;
	}

	codeSerializer.AddLine("break;");
}

void PredaRealListener::exitBreakStatement(PredaParser::BreakStatementContext *ctx)
{
}


void PredaRealListener::enterStatement(PredaParser::StatementContext *ctx)
{
}

void PredaRealListener::exitStatement(PredaParser::StatementContext *ctx)
{
	if (!ctx->userBlockStatement())
	{
		if (!m_transpilerCtx.functionCtx.IsInsideBranchBlock())
		{
			m_lastStatementInFunctionIsReturnStatement = (ctx->returnStatement() != nullptr);
		}
	}
}

bool PredaRealListener::ReservedFunctions_OnDeclare(std::string &name, transpiler::FunctionSignature &signature)
{
	bool bMustBeShard = false;
	bool bMustBeGlobal = false;
	bool bMayNotHaveParam = false;
	bool bMustHaveSingleBoolParam = false;

	if (name == "on_deploy")
	{
		bMustBeGlobal = true;
		bMayNotHaveParam = true;
	}
	else if (name == "on_scaleout")
	{
		bMustBeShard = true;
		bMustHaveSingleBoolParam = true;
	}
	else
		return true;

	signature.flags |= uint32_t(transpiler::PredaFunctionFlags::CallableFromSystem);

	if (bMustBeShard && transpiler::PredaFunctionFlags(signature.flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) != transpiler::PredaFunctionFlags::ContextClassShard)
	{
		m_errorPortal.AddReservedFunctionMustBeShardError(name);
		return false;
	}

	if (bMustBeGlobal && transpiler::PredaFunctionFlags(signature.flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) != transpiler::PredaFunctionFlags::ContextClassGlobal)
	{
		m_errorPortal.AddReservedFunctionMustBeGlobalError(name);
		return false;
	}

	if (signature.returnType.baseConcreteType != nullptr)
	{
		m_errorPortal.AddReservedFunctionMayNotHaveReturnValueError(name);
		return false;
	}

	if (bMayNotHaveParam && signature.parameters.size() != 0)
	{
		m_errorPortal.AddReservedFunctionMayNotHaveParametersError(name);
		return false;
	}
	if (bMustHaveSingleBoolParam && (signature.parameters.size() != 1 || signature.parameters[0]->qualifiedType.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType()))
	{
		m_errorPortal.AddReservedFunctionMustHaveSingleBooleanParameterError(name);
		return false;
	}

	if ((signature.flags & (uint32_t(transpiler::PredaFunctionFlags::CallableFromTransaction) | uint32_t(transpiler::PredaFunctionFlags::CallableFromOtherContract))) != 0)
	{
		m_errorPortal.AddReservedFunctionCannotBePublicOrExportError(name);
		return false;
	}

	return true;
}

void PredaRealListener::ReservedFunctions_PostExport(const std::string &name, const transpiler::FunctionSignature &signature, size_t exportIdx)
{
	int32_t *pTarget = nullptr;
	if (name == "on_deploy")
		pTarget = &m_globalDeployFunctionExportIdx;
	else if (name == "on_scaleout")
		pTarget = &m_shardScaleOutFunctionExportIdx;

	if (pTarget != nullptr)
	{
		if (*pTarget != -1)
		{
			m_errorPortal.AddInternalError("reserved function " + name + "redefinition. Probably a compiler bug.");
			return;
		}

		*pTarget = (int32_t)exportIdx;
	}

	return;
}

bool PredaRealListener::GenFunctionSignatureFromFunctionDeclareCtx(transpiler::FunctionSignature& outSig, PredaParser::FunctionDeclarationContext* declCtx)
{
	if (!declCtx)
		return false;

	//context-class specifier
	if (declCtx->scope())
	{
		if (declCtx->scope()->ShardKeyword())
			outSig.flags |= uint32_t(transpiler::PredaFunctionFlags::ContextClassShard);
		else if (declCtx->scope()->GlobalKeyword())
			outSig.flags |= uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal);
		else if (declCtx->scope()->AddressKeyword())
			outSig.flags |= uint32_t(transpiler::PredaFunctionFlags::ContextClassAddress);
		else
		{
			m_errorPortal.AddInternalError(declCtx->identifier()->start, "unknown context class specifier \"" + declCtx->scope()->getText() + "\". Probably compiler bug.");
			return false;
		}
	}
	else
	{
		// defaults to per-address function
		outSig.flags |= uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal);
	}

	//function return type
	if (declCtx->functionReturnTypeName())
	{
		ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(declCtx->functionReturnTypeName()->typeName());
		if (pType == nullptr)
			return false;
		if (pType->typeCategory == transpiler::ConcreteType::ContractType)
		{
			m_errorPortal.SetAnchor(declCtx->functionReturnTypeName()->typeName()->start);
			m_errorPortal.AddIllegalUseOfContractTypeError();
			return  false;
		}

		outSig.returnType = transpiler::QualifiedConcreteType(pType, declCtx->functionReturnTypeName()->ConstantKeyword() != nullptr, false);
	}
	else
		outSig.returnType = transpiler::QualifiedConcreteType(nullptr, true, false);

	//function name
	// not using IdentifierHub::ValidateNewIdentifier() here because functions could be overloaded and hence can reuse same name.
	std::string functionName = declCtx->identifier()->getText();
	if (functionName.find("__") != std::string::npos)
	{
		m_errorPortal.SetAnchor(declCtx->identifier()->start);
		m_errorPortal.AddIdentifierTwoUnderscoreError();
		return false;
	}
	//doxygen comment
	if (declCtx->doxygen()) {
		outSig.doxygenComment = ProcessDoxygen(declCtx->doxygen());
	}

	//access specifiers
	std::vector<PredaParser::AccessSpecifierContext*> accessSpecifiers = declCtx->accessSpecifier();
	for (size_t i = 0; i < accessSpecifiers.size(); i++)
	{
		std::string accessSpecifier = accessSpecifiers[i]->getText();
		if (accessSpecifiers[i]->ExportKeyword() != nullptr)
			outSig.flags |= uint32_t(transpiler::PredaFunctionFlags::CallableFromTransaction);
		else if (accessSpecifiers[i]->PublicKeyword() != nullptr)
			outSig.flags |= uint32_t(transpiler::PredaFunctionFlags::CallableFromOtherContract);
		else
			assert(0);
	}
	bool bIsTransactionFunction = (outSig.flags & uint32_t(transpiler::PredaFunctionFlags::CallableFromTransaction)) != 0;

	//parameters
	std::vector<PredaParser::FunctionParameterContext*> vParamCtx = declCtx->functionParameterList()->functionParameter();
	for (size_t i = 0; i < vParamCtx.size(); i++)
	{
		// function parameters are defined in the current scope (function scope)
		bool bIsConst = (vParamCtx[i]->ConstantKeyword() != nullptr);
		ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(vParamCtx[i]->typeName());
		if (pType == nullptr)
			return false;
		if (pType->typeCategory == transpiler::ConcreteType::ContractType)
		{
			m_errorPortal.SetAnchor(vParamCtx[i]->typeName()->start);
			m_errorPortal.AddIllegalUseOfContractTypeError();
			return false;
		}

		if (bIsTransactionFunction && (pType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
		{
			m_errorPortal.SetAnchor(vParamCtx[i]->typeName()->start);
			m_errorPortal.AddMoveOnlyParamOfTxnFunctionError();
			return false;
		}

		transpiler::DefinedIdentifierPtr pDefinedVariable = DefineFunctionLocalVariable(pType, vParamCtx[i]->identifier(), bIsConst, 0);
		if (pDefinedVariable == nullptr)
			return false;
	}
	outSig.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

	// const qualifier
	if (declCtx->ConstantKeyword() != nullptr)
		outSig.flags = outSig.flags | uint32_t(transpiler::PredaFunctionFlags::IsConst);

	return true;
}

void PredaRealListener::ForwardDeclareFunction(PredaParser::FunctionDefinitionContext *ctx)
{
	PredaParser::FunctionDeclarationContext* declCtx = ctx->functionDeclaration();

	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global function definition is not supported yet, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	m_transpilerCtx.functionCtx.PushFunctionScope(thisType->CreateInnerUnnamedScopeType("forward_declare_" + declCtx->identifier()->getText()));
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	transpiler::FunctionSignature functionSignature;

	if (!GenFunctionSignatureFromFunctionDeclareCtx(functionSignature, declCtx))
		return;

	std::string functionName = declCtx->identifier()->getText();
	{
		ConcreteTypePtr type;
		transpiler::DefinedIdentifierPtr pIdentifier;
		if (m_identifierHub.FindExistingIdentifier(functionName, &type, &pIdentifier))
		{
			// not an overloaded function in the same scope
			if (!(pIdentifier != nullptr 
				&& pIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType
				&& pIdentifier->qualifiedType.baseConcreteType->outerType == thisType))
			{
				m_errorPortal.SetAnchor(declCtx->identifier()->start);
				m_errorPortal.AddIdentifierRedefinitionError(functionName);
				return;
			}
		}
	}

	// reserved functions are only for contracts
	if (thisType->typeCategory == transpiler::ConcreteType::ContractType)
	{
		m_errorPortal.SetAnchor(declCtx->identifier()->start);
		if (!ReservedFunctions_OnDeclare(functionName, functionSignature))
			return;
	}

	transpiler::DefinedIdentifierPtr pDefinedFunction = thisType->DefineMemberFunction(functionName, functionSignature, false);
	if (pDefinedFunction == nullptr)
	{
		m_errorPortal.SetAnchor(declCtx->identifier()->start);
		m_errorPortal.AddFunctionRedefinitionError();
		return;
	}

	ForwardDeclaredContractFunction forwardDeclearedFunc;
	forwardDeclearedFunc.declaredFunc.functionIdentifier = pDefinedFunction;
	forwardDeclearedFunc.declaredFunc.overloadIndex = pDefinedFunction->qualifiedType.baseConcreteType->vOverloadedFunctions.size() - 1;
	forwardDeclearedFunc.ctx = ctx;
	m_forwardDeclaredFunctions.push_back(forwardDeclearedFunc);
	m_functionDefinitionContext2ForwardDeclaredFunctions.insert(std::make_pair(ctx, m_forwardDeclaredFunctions.size() - 1));

	// generate export signature
	bool bNeedToExport = (functionSignature.flags &
		(	uint32_t(transpiler::PredaFunctionFlags::CallableFromRelay)
			| uint32_t(transpiler::PredaFunctionFlags::CallableFromTransaction)
			| uint32_t(transpiler::PredaFunctionFlags::CallableFromOtherContract) 
			| uint32_t(transpiler::PredaFunctionFlags::CallableFromSystem))
		)
		!= 0;

	if (bNeedToExport)
	{
		size_t exportSlot = ExportFunction(forwardDeclearedFunc.declaredFunc);

		// reserved functions are only for contracts
		if (thisType->typeCategory == transpiler::ConcreteType::ContractType)
		{
			m_errorPortal.SetAnchor(declCtx->identifier()->start);
			ReservedFunctions_PostExport(functionName, functionSignature, exportSlot);
		}
	}
}

void PredaRealListener::DefineInterface(PredaParser::InterfaceDefinitionContext* ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global scope interface definition is not supported yet by the PREDA grammar, hence this should hold
	assert(thisType != nullptr);

	std::string interfaceTypeName = ctx->identifier()->getText();
	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;

	ConcreteTypePtr interfaceType = thisType->CreateInnerInterfaceType(interfaceTypeName);

	{
		transpiler::FunctionSignature signature;

		//function return type
		signature.returnType = transpiler::QualifiedConcreteType(interfaceType, true, false);		// struct constructor returns a non-lvalue const instance

		signature.flags = uint32_t(transpiler::PredaFunctionFlags::IsConst);

		// constructor with uint64 contract id
		signature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, true, "contract_id", 0));
		bool res = interfaceType->DefineMemberFunction("@constructor", signature, false) != nullptr;
		assert(res);
	}

	std::vector<PredaParser::FunctionDeclarationContext*> functionDeclarations = ctx->functionDeclaration();
	for (uint32_t i = 0; i < uint32_t(functionDeclarations.size()); i++)
	{
		PredaParser::FunctionDeclarationContext* declCtx = functionDeclarations[i];
		m_transpilerCtx.functionCtx.PushFunctionScope(interfaceType->CreateInnerUnnamedScopeType("interface_function_declare_" + declCtx->identifier()->getText()));
		AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

		transpiler::FunctionSignature functionSignature;
		if (!GenFunctionSignatureFromFunctionDeclareCtx(functionSignature, declCtx))
			continue;

		std::string functionName = declCtx->identifier()->getText();
		transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->DefineMemberFunction(functionName, functionSignature, false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.SetAnchor(declCtx->identifier()->start);
			m_errorPortal.AddFunctionRedefinitionError();
			continue;
		}
	}

	m_definedInterfaces.emplace_back(interfaceType);
}

size_t PredaRealListener::ExportFunction(transpiler::FunctionRef functionRef)
{
	for (size_t i = 0; i < m_exportedFunctions.size(); i++)
	{
		if (m_exportedFunctions[i].functionIdentifier == functionRef.functionIdentifier && m_exportedFunctions[i].overloadIndex == functionRef.overloadIndex)
			return i;
	}

	m_exportedFunctions.push_back(functionRef);

	return m_exportedFunctions.size() - 1;
}

void PredaRealListener::DefineStateVariable(PredaParser::StateVariableDeclarationContext *ctx)
{
	//context-class specifier
	uint32_t flags = 0;
	if (ctx->scope())
	{
		if (ctx->scope()->ShardKeyword())
			flags |= uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassShard);
		else if (ctx->scope()->GlobalKeyword())
			flags |= uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassGlobal);
		else if (ctx->scope()->AddressKeyword())
			flags |= uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassAddress);
		else
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "unknown context class specifier \"" + ctx->scope()->getText() + "\". Probably a compiler bug.");
			return;
		}
	}
	else
	{
		flags |= uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassGlobal);
	}

	ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(ctx->typeName());
	if (pType == nullptr)
		return;

	if ((pType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::HasBlob)) != 0
		&& ((flags & uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassMask)) == uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassGlobal)))
	{
		m_errorPortal.SetAnchor(ctx->typeName()->start);
		m_errorPortal.AddBlobInGlobalStateVariableError();
		return;
	}

	if (pType->typeCategory == transpiler::ConcreteType::ContractType)
	{
		m_errorPortal.SetAnchor(ctx->typeName()->start);
		m_errorPortal.AddIllegalUseOfContractTypeError();
		return;
	}

	assert(m_transpilerCtx.thisPtrStack.stack.size() > 0);

	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;
	
	// state variables are always non-const
	transpiler::DefinedIdentifierPtr pDefinedVariable = m_transpilerCtx.thisPtrStack.stack.back().thisType->DefineMemberVariable(pType, ctx->identifier()->getText(), flags, false, true, false);
	if (pDefinedVariable != nullptr)
		m_definedStateVariables.push_back(std::make_pair(ctx, *pDefinedVariable));
}

void PredaRealListener::DefineStruct(PredaParser::StructDefinitionContext *ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global scope struct definition is not supported yet by the PREDA grammar, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	std::string structTypeName = ctx->identifier()->getText();
	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;

	if (ctx->variableDeclaration().size() == 0)
	{
		m_errorPortal.SetAnchor(ctx->identifier()->start);
		m_errorPortal.AddEmptyStructError();
		return;
	}
	// struct members cannot reference the struct type itself. Therefore their types are checked before defining the struct type.
	std::vector<ConcreteTypePtr> memberTypes;
	{
		std::vector<PredaParser::VariableDeclarationContext*> memberVariableDclarations = ctx->variableDeclaration();
		for (size_t i = 0; i < memberVariableDclarations.size(); i++)
			 memberTypes.push_back(m_identifierHub.GetTypeFromTypeNameContext(memberVariableDclarations[i]->typeName()));
	}

	// Register the struct type
	ConcreteTypePtr structType = thisType->CreateInnerUserDefinedStructType(structTypeName);
	if (structType == nullptr)
	{
		m_errorPortal.AddInternalError(ctx->identifier()->start, "struct type \"" + structTypeName + "\" cannot be defined. Unknown error.");
		return;
	}

	//doxygen comment
	if(ctx->doxygen()){
		structType->doxygenComment = ProcessDoxygen(ctx->doxygen());
	}

	m_transpilerCtx.thisPtrStack.Push(structType, false);
	AUTO_POP_THIS_PTR_STACK;

	std::vector<transpiler::DefinedIdentifierPtr> members;
	{
		std::vector<PredaParser::VariableDeclarationContext*> memberVariableDeclarations = ctx->variableDeclaration();
		for (size_t i = 0; i < memberVariableDeclarations.size(); i++)
		{
			ConcreteTypePtr pType = memberTypes[i];
			if (pType == nullptr)
				continue;

			if (pType->typeCategory == transpiler::ConcreteType::ContractType)
			{
				m_errorPortal.SetAnchor(memberVariableDeclarations[i]->typeName()->start);
				m_errorPortal.AddIllegalUseOfContractTypeError();
				continue;
			}

			if (!m_identifierHub.ValidateNewIdentifier(memberVariableDeclarations[i]->identifier()))
				continue;

			transpiler::DefinedIdentifierPtr pMember = structType->DefineMemberVariable(pType, memberVariableDeclarations[i]->identifier()->getText(), 0, false, true, false);
			if (pMember == nullptr)
			{
				m_errorPortal.AddInternalError(memberVariableDeclarations[i]->identifier()->start, "identifier \"" + memberVariableDeclarations[i]->identifier()->getText() + "\" already used. Probably a compile bug.");
				continue;
			}

			members.push_back(pMember);
		}
	}

	// Add a constructor function to functions, which takes all members as parameters
	{
		transpiler::FunctionSignature signature;

		//function return type
		signature.returnType = transpiler::QualifiedConcreteType(structType, false, false);		// struct constructor returns a non-lvalue non-const instance

		signature.flags = uint32_t(transpiler::PredaFunctionFlags::IsConst);

		// Default constructor with no parameters
		{
			bool res = structType->DefineMemberFunction("@constructor", signature, false) != nullptr;
			assert(res);
		}

		// constructor with a list of initial member variable values as parameters
		if (members.size() > 0)
		{
			//parameters are just the struct members. All passed-in as const
			for (size_t i = 0; i < members.size(); i++)
				signature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(members[i]->qualifiedType.baseConcreteType, true, true, members[i]->inputName, 0));

			bool res = structType->DefineMemberFunction("@constructor", signature, false) != nullptr;
			assert(res);
		}
	}

	m_definedStructs.push_back(std::make_pair(ctx, structType));
}

void PredaRealListener::DefineEnum(PredaParser::EnumDefinitionContext *ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global scope enum definition is not supported yet by the PREDA grammar, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	std::vector<PredaParser::IdentifierContext*> identifiers = ctx->identifier();
	if (!m_identifierHub.ValidateNewIdentifier(identifiers[0]))
		return;
	if (identifiers.size() > 65536)		//the first identifier is the type name, hence 65536 instead of 65535 here
	{
		m_errorPortal.SetAnchor(identifiers[0]->start);
		m_errorPortal.AddTooManyEnumeratorsError();
		return;
	}

	std::string enumTypeName = identifiers[0]->getText();

	ConcreteTypePtr enumType = thisType->CreateInnerEnumType(enumTypeName);
	if (enumType == nullptr)
	{
		m_errorPortal.AddInternalError(identifiers[0]->start, "enum type \"" + enumTypeName + "\" cannot be defined. Unknown error.");
		return;
	}

	m_transpilerCtx.thisPtrStack.Push(enumType, false);
	AUTO_POP_THIS_PTR_STACK;

	bool bNoError = true;
	std::vector<std::string> definedIdentifierNames;
	for (size_t i = 1; i < identifiers.size(); i++)
	{
		if (!m_identifierHub.ValidateNewIdentifier(identifiers[i]))
		{
			bNoError = false;
			continue;
		}

		if (enumType->DefineMemberVariable(enumType, identifiers[i]->getText(), 0, true, false, true) == nullptr)
		{
			m_errorPortal.AddInternalError(identifiers[i]->start, "identifier \"" + identifiers[i]->getText() + "\" already used. Probably compiler bug.");
			return;
		}
	}

	if (bNoError)
		m_definedEnums.push_back(std::make_pair(ctx, enumType));
}

void PredaRealListener::enterContractDefinition(PredaParser::ContractDefinitionContext *ctx)
{
	m_pWalker->SkipCurrentRuleSubtree();

	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;

	if(ctx->doxygen()){
		m_currentDoxygenComment = ProcessDoxygen(ctx->doxygen());
	}

	std::string contractFullName = m_currentDAppName + "." + m_currentContractName;
	if (m_pContractSymbolDatabase->ContractExists(m_currentDAppName.c_str(), m_currentContractName.c_str()))
	{
		m_errorPortal.SetAnchor(ctx->identifier()->start);
		m_errorPortal.AddContractNameAlreadyUsedError(contractFullName);
		return;
	}
	m_contractAliasToFullName.emplace(m_currentContractName, contractFullName);

	ConcreteTypePtr contractType = m_transpilerCtx.globalType->CreateInnerContractType(m_currentContractName, contractFullName);
	if (contractType == nullptr)
	{
		m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot declare contract type \"" + m_currentContractName + "\". Probably compiler bug.");
		return;
	}

	m_transpilerCtx.thisPtrStack.Push(contractType, false);

	m_currentContractOutputName = contractType->outputFullName;
	codeSerializer.AddLine("struct " + m_currentContractOutputName + " {");
	codeSerializer.PushIndent();

	// We have a two pass algorithm for declaration and definitions in a contract
	// Here is the first pass that forward declares all struct types, functions, and defines all enumeration types and state variables 
	std::vector<PredaParser::ContractPartContext*> contractParts = ctx->contractPart();
	for (size_t i = 0; i < contractParts.size(); i++)
	{
		if (contractParts[i]->stateVariableDeclaration())
		{
			DefineStateVariable(contractParts[i]->stateVariableDeclaration());
		}
		else if (contractParts[i]->structDefinition())
		{
			DefineStruct(contractParts[i]->structDefinition());
		}
		else if (contractParts[i]->enumDefinition())
		{
			DefineEnum(contractParts[i]->enumDefinition());
		}
		else if (contractParts[i]->functionDefinition())
		{
			ForwardDeclareFunction(contractParts[i]->functionDefinition());
		}
		else if (contractParts[i]->interfaceDefinition())
		{
			DefineInterface(contractParts[i]->interfaceDefinition());
		}
	}

	// Generate code for enum types
	for (auto itor : m_definedEnums)
	{
		ContractEnum enumerate;
		std::vector<PredaParser::IdentifierContext*> identifiers = itor.first->identifier();
		enumerate.name = identifiers[0]->getText();

		ConcreteTypePtr enumType = contractType->FindInnerConcreteType(enumerate.name);
		if (enumType == nullptr)
			continue;

		std::string enumTypeOutputName = enumType->outputFullName.substr(enumType->outputFullName.rfind("::") + 2);
		if(itor.first->doxygen()){
			enumerate.doxygenComment = ProcessDoxygen(itor.first->doxygen());
		}

		enumerate.enumerators = std::vector<std::string>();
		m_exportedEnums.emplace_back(enumerate);

		codeSerializer.AddLine("enum class " + enumTypeOutputName + "__ : prlrt::enum_base_type {");
		codeSerializer.PushIndent();
		for (size_t i = 0; i < enumType->members.size(); i++)
		{
			codeSerializer.AddLine(enumType->members[i]->outputName + " = " + std::to_string(i) + ",");
			m_exportedEnums.back().enumerators.push_back(enumType->members[i]->inputName);
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("};");
		codeSerializer.AddLine("using " + enumTypeOutputName + " = prlrt::enum_wrapper<" + enumTypeOutputName + "__, " + std::to_string(identifiers.size() - 1) + ">;");
		codeSerializer.AddLine("");
	}

	// Generate code for struct types
	for (auto itor : m_definedStructs)
	{
		ConcreteTypePtr structType = itor.second;
		if (structType == nullptr)
			continue;

		m_exportedStructs.emplace_back();

		codeSerializer.AddLine("#define EXPAND_STRUCT_MEMBER_LIST\\");
		codeSerializer.PushIndent();

		std::string structTypeName = itor.first->identifier()->getText();
		std::string structDoxygenComment;
		if(itor.first->doxygen() != nullptr){
			structDoxygenComment = ProcessDoxygen(itor.first->doxygen());
		}

		m_exportedStructs.back().name = structTypeName;
		m_exportedStructs.back().doxygenComment = structDoxygenComment;
		std::string structTypeOutputName;
		{
			ConcreteTypePtr structType = contractType->FindInnerConcreteType(structTypeName);
			if (structType == nullptr)
				continue;
			structTypeOutputName = structType->outputFullName.substr(structType->outputFullName.rfind("::") + 2);
		}

		std::vector<transpiler::DefinedIdentifierPtr> memberVariables;
		for (size_t i = 0; i < structType->members.size(); i++)
		{
			if (structType->members[i]->qualifiedType.baseConcreteType->typeCategory != transpiler::ConcreteType::FunctionType)
				memberVariables.push_back(structType->members[i]);
		}
		for (size_t i = 0; i < memberVariables.size(); i++)
		{
			if (i > 0)
				codeSerializer.AddLine("SPLITTER\\");
			codeSerializer.AddLine("EXPAND_STRUCT_MEMBER((" + memberVariables[i]->qualifiedType.baseConcreteType->outputFullName + "), " + memberVariables[i]->outputName + ")" + (i < memberVariables.size() - 1 ? "\\" : ""));
			m_exportedStructs.back().members.emplace_back(memberVariables[i]->qualifiedType.baseConcreteType->exportName, memberVariables[i]->inputName);
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("#define STRUCT_MEMBER_COUNT " + std::to_string(memberVariables.size()));
		codeSerializer.AddLine("#define STRUCT_INTERNAL_NAME " + structTypeOutputName + "__");
		codeSerializer.AddLine("#define STRUCT_NAME " + structTypeOutputName);
		codeSerializer.AddLine("#include \"include/define_struct.h\"");

		// TODO: add a copy constructor for the struct and serialize its code

		codeSerializer.AddLine("");
	}

	// Generate code for interfaces
	for (auto itor : m_definedInterfaces)
	{
		ConcreteTypePtr interfaceType = itor;
		if (interfaceType == nullptr)
			continue;
		assert(interfaceType->typeCategory == transpiler::ConcreteType::InterfaceType);

		codeSerializer.AddLine("struct " + interfaceType->outputFullName.substr(interfaceType->outputFullName.rfind("::") + 2) + " : public prlrt::interface_struct {");
		codeSerializer.PushIndent();
		codeSerializer.AddLine("INTERFACE_INHERIT");

		for (size_t i = 0; i < interfaceType->vInterfaceMemberFuncIndexMapping.size(); i++)
		{
			transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->vInterfaceMemberFuncIndexMapping[i].first;
			if (pDefinedFunction == nullptr)
				continue;
			ConcreteTypePtr funcType = pDefinedFunction->qualifiedType.baseConcreteType;
			assert(funcType && funcType->typeCategory == transpiler::ConcreteType::FunctionType);
			const transpiler::FunctionSignature & functionSignature = funcType->vOverloadedFunctions[interfaceType->vInterfaceMemberFuncIndexMapping[i].second];

			GenerateCodeForInterfaceFunction(codeSerializer, interfaceType->exportName, pDefinedFunction->outputName, functionSignature, uint32_t(i));
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("};");
	}

	// Generate code for state variables
	{
		transpiler::PredaDefinedVariableFlags perSectionFlags[] = { transpiler::PredaDefinedVariableFlags::ContextClassGlobal, transpiler::PredaDefinedVariableFlags::ContextClassShard, transpiler::PredaDefinedVariableFlags::ContextClassAddress };
		std::string perSectionNames[] = { "global", "shard", "address" };
		static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionNames) / sizeof(perSectionNames[0]), "state variable section metadata length doesn't match");

		constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

		for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
		{
			m_stateVariableSignature[uint8_t(perSectionFlags[sectionIdx])] = "struct";

			std::string signature;
			bool hasBlob = false;
			bool hasAsset = false;
			uint32_t numSectionVar = 0;
			std::string doxygenComment;
			m_stateVariableDoxygenComment[uint8_t(perSectionFlags[sectionIdx])] = std::vector<std::string>();
			for (auto itor : m_definedStateVariables)
			{
				// state variables are always non-const
				transpiler::DefinedIdentifier definedVariable = itor.second;

				if ((definedVariable.flags & uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassMask)) == uint32_t(perSectionFlags[sectionIdx]))
				{
					if(itor.first->doxygen()){
						m_stateVariableDoxygenComment[uint8_t(perSectionFlags[sectionIdx])].push_back(ProcessDoxygen(itor.first->doxygen()));
					}
					std::string line = definedVariable.qualifiedType.baseConcreteType->outputFullName + " " + definedVariable.outputName;
					line += ";";
					codeSerializer.AddLine(line);

					numSectionVar++;
					signature += " " + definedVariable.qualifiedType.baseConcreteType->exportName + " " + definedVariable.inputName;
					if ((definedVariable.qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::HasBlob)) != 0)
						hasBlob = true;
					if ((definedVariable.qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::HasAsset)) != 0)
						hasAsset = true;
				}
			}
			if (numSectionVar > 0)
				codeSerializer.AddLine("");

			m_stateVariableSignature[uint8_t(perSectionFlags[sectionIdx])] += " " + std::to_string(numSectionVar) + signature;
			m_stateVariableHasBlob[uint8_t(perSectionFlags[sectionIdx])] = hasBlob;
			m_stateVariableHasAsset[uint8_t(perSectionFlags[sectionIdx])] = hasAsset;
		}
	}

	// __id()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__id", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::PredaFunctionFlags::IsConst)
		), true);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot define built-in function __id() for contract. Probably compiler bug.");
			return;
		}
		codeSerializer.AddLine("static " + m_transpilerCtx.GetBuiltInIntegerType(64, false)->outputFullName + " __prli___id() { return __prli___cur_contract_id; }");
	}

	// __mint()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__mint", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInTokenType(), false, false),
			{transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInBigIntType(), true, true, "amount", 0)},
			uint32_t(transpiler::PredaFunctionFlags::IsConst)
		), true);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot define built-in function __mint() for contract. Probably compiler bug.");
			return;
		}
		codeSerializer.AddLine("static " + m_transpilerCtx.GetBuiltInTokenType()->outputFullName + " __prli___mint(__prlt_bigint amount) { return prlrt::mint(__prli___cur_contract_id, amount); }");
	}

	TraverseAllFunctions();
}

void PredaRealListener::TraverseAllFunctions()
{
	// traverse global functions first
	for (ForwardDeclaredContractFunction &func : m_forwardDeclaredFunctions)
	{
		transpiler::FunctionSignature* pSig = func.declaredFunc.GetSignature();
		if (pSig && (pSig->flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) == uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal))
		{
			PredaParseTreeWalker* oldWalker = m_pWalker;
			PredaParseTreeWalker newWalker;
			SetWalker(&newWalker);
			m_curFunc = &func;
			m_pWalker->walk(this, func.ctx);
			SetWalker(oldWalker);
		}
	}

	// propagate flags once so that HasRelayShardsStatement is propagated across the global functions, which will be used later to ensure that a non-global function is not calling a global function that relay@shards
	// Note that since HasRelayShardsStatement flag is only allowed on global functions, they cannot propagate through non-global functions, hence propagating right here is sufficient
	PropagateFunctionFlagAcrossCallingGraph();

	// traverse non-global functions
	for (ForwardDeclaredContractFunction& func : m_forwardDeclaredFunctions)
	{
		transpiler::FunctionSignature* pSig = func.declaredFunc.GetSignature();
		if (pSig && (pSig->flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) != uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal))
		{
			PredaParseTreeWalker* oldWalker = m_pWalker;
			PredaParseTreeWalker newWalker;
			SetWalker(&newWalker);
			m_curFunc = &func;
			m_pWalker->walk(this, func.ctx);
			SetWalker(oldWalker);
		}
	}
}

void PredaRealListener::DefinePendingRelayLambdas()
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global function definition is not supported yet, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	for (size_t i = 0; i < m_pendingRelayLambdas.size(); i++)
	{
		PendingRelayLambda &lambda = m_pendingRelayLambdas[i];
		PredaParser::RelayLambdaDefinitionContext *ctx = lambda.pDefinitionCtx;

		//function name
		std::string functionName = "__relaylambda_" + std::to_string(lambda.exportFuncSlot) + "_" + lambda.baseFunc->declaredFunc.functionIdentifier->inputName;
		m_curFunc = lambda.baseFunc;
		m_transpilerCtx.functionCtx.PushFunctionScope(thisType->CreateInnerUnnamedScopeType("function_" + functionName));
		AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

		transpiler::FunctionSignature functionSignature;

		functionSignature.flags = uint32_t(transpiler::PredaFunctionFlags::CallableFromRelay);
		if (lambda.relayType == RelayType::Address)
			functionSignature.flags |= uint32_t(transpiler::PredaFunctionFlags::ContextClassAddress);
		else if (lambda.relayType == RelayType::Shards)
			functionSignature.flags |= uint32_t(transpiler::PredaFunctionFlags::ContextClassShard);
		else if (lambda.relayType == RelayType::Global)
			functionSignature.flags |= uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal);
		else
			assert(0);

		functionSignature.returnType = transpiler::QualifiedConcreteType(nullptr, true, false);

		//parameters
		std::vector<PredaParser::RelayLambdaParameterContext*> vParamNameCtxs = lambda.pDefinitionCtx->relayLambdaParameter();
		for (size_t i = 0; i < vParamNameCtxs.size(); i++)
		{
			// function parameters are defined in the current scope (function scope)
			if (DefineFunctionLocalVariable(lambda.paramTypes[i].baseConcreteType, vParamNameCtxs[i]->identifier(), lambda.paramTypes[i].bIsConst, 0) == nullptr)
				return;
		}

		functionSignature.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

		// const qualifier
		if (ctx->ConstantKeyword() != nullptr)
			functionSignature.flags = functionSignature.flags | uint32_t(transpiler::PredaFunctionFlags::IsConst);

		transpiler::DefinedIdentifierPtr pDefinedFunction = thisType->DefineMemberFunction(functionName, functionSignature, false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->start, "cannot define relay lambda function with name \"" + functionName + "\", the identifier is already used. Probably a bug in transpiler.");
			return;
		}

		m_exportedFunctions[lambda.exportFuncSlot].functionIdentifier = pDefinedFunction;
		m_exportedFunctions[lambda.exportFuncSlot].overloadIndex = pDefinedFunction->qualifiedType.baseConcreteType->vOverloadedFunctions.size() - 1;


		// Copy the function signature to the current scope on the stack. (return statement will rely on this info to check return type
		m_transpilerCtx.functionCtx.functionRef = m_exportedFunctions[lambda.exportFuncSlot];

		m_lastStatementInFunctionIsReturnStatement = false;

		m_transpilerCtx.thisPtrStack.Push(thisType, (functionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::IsConst)) != 0);
		AUTO_POP_THIS_PTR_STACK;

		{
			std::string line;
			if (functionSignature.returnType.baseConcreteType == nullptr)
			{
				line += "void";
			}
			else
			{
				line += functionSignature.returnType.baseConcreteType->outputFullName;
				if (!functionSignature.returnType.bIsConst)
					line += "&";
			}
			line += " " + pDefinedFunction->outputName + "(";
			for (size_t i = 0; i < functionSignature.parameters.size(); i++)
			{
				if (i > 0)
					line += ", ";
				if (functionSignature.parameters[i]->qualifiedType.bIsConst)
					line += "const ";
				line += functionSignature.parameters[i]->qualifiedType.baseConcreteType->outputFullName + " " + functionSignature.parameters[i]->outputName;
			}
			line += ")";
			if ((functionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::IsConst)) != 0)
				line += " const";
			line += " { prlrt::burn_gas_function_call();";
			codeSerializer.AddLine(line);
			codeSerializer.PushIndent();
		}

		PredaParseTreeWalker *oldWalker = m_pWalker;
		PredaParseTreeWalker newWalker;
		SetWalker(&newWalker);
		m_pWalker->walk(this, ctx);
		SetWalker(oldWalker);

		if (m_transpilerCtx.functionCtx.GetFunctionSignature()->returnType.baseConcreteType != nullptr && !m_lastStatementInFunctionIsReturnStatement)
		{
			m_errorPortal.SetAnchor(ctx->stop);
			m_errorPortal.AddNoReturnFromFunctionWithReturnTypeError();
			return;
		}

		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
	}
}

void PredaRealListener::GenerateAuxiliaryFunctions()
{
	codeSerializer.AddLine("");
	codeSerializer.AddLine("extern \"C\" {");
	codeSerializer.PushIndent();
	{
		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_TransactionCallEntry(void *pContractInstance, uint32_t functionId, uint8_t *args, uint32_t args_size) {");
		codeSerializer.PushIndent();
		{
			uint32_t numTransactionOrRelayFunction = 0;
			for (size_t funcIdx = 0; funcIdx < m_exportedFunctions.size(); funcIdx++)
			{
				transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
				if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
					continue;
				transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];
				bool bIsTransactionOrRelayFunction = (signature.flags &
					(uint32_t(transpiler::PredaFunctionFlags::CallableFromTransaction)
						| uint32_t(transpiler::PredaFunctionFlags::CallableFromRelay)
						| uint32_t(transpiler::PredaFunctionFlags::CallableFromSystem))
					) != 0;
				if (bIsTransactionOrRelayFunction)
					numTransactionOrRelayFunction++;
			}

			if (numTransactionOrRelayFunction == 0)
			{
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::FunctionNotFound);");
			}
			else
			{
				codeSerializer.AddLine("try {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("switch (functionId){");
					for (size_t funcIdx = 0; funcIdx < m_exportedFunctions.size(); funcIdx++)
					{
						transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
						if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
							continue;
						transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];
						bool bIsTransactionOrRelayOrSystemFunction = (signature.flags & 
							(uint32_t(transpiler::PredaFunctionFlags::CallableFromTransaction)
								| uint32_t(transpiler::PredaFunctionFlags::CallableFromRelay)
								| uint32_t(transpiler::PredaFunctionFlags::CallableFromSystem))
							) != 0;
						if (bIsTransactionOrRelayOrSystemFunction)
						{
							codeSerializer.AddLine("case " + std::to_string(funcIdx) + ":");
							codeSerializer.AddLine("{");
							codeSerializer.PushIndent();
							{
								for (size_t paramIdx = 0; paramIdx < signature.parameters.size(); paramIdx++)
								{
									codeSerializer.AddLine(signature.parameters[paramIdx]->qualifiedType.baseConcreteType->outputFullName + " arg" + std::to_string(paramIdx) + ";");
									// TODO: deep validate args (e.g. vector serialization buffer offset out-of-range, when user fakes an invalid transaction call)
									codeSerializer.AddLine("if (!arg" + std::to_string(paramIdx) + ".map_from_serialized_data(args, args_size, true)) return uint32_t(prlrt::ExecutionError::ArgumentDeserializationFailure);");
								}
								codeSerializer.AddLine("if (args_size != 0) return uint32_t(prlrt::ExecutionError::ArgumentDeserializationFailure);");

								std::string line;
								if (signature.returnType.baseConcreteType != nullptr)
									line = signature.returnType.baseConcreteType->outputFullName + " ret = ";
								line += "((" + m_currentContractOutputName + " *)pContractInstance)->" + curFunc.functionIdentifier->outputName + "(";
								for (size_t paramIdx = 0; paramIdx < signature.parameters.size(); paramIdx++)
									line += (paramIdx > 0 ? ", arg" : "arg") + std::to_string(paramIdx);
								codeSerializer.AddLine(line + ");");
								if (signature.returnType.baseConcreteType != nullptr)
									codeSerializer.AddLine("prlrt::report_return_value(\"" + signature.returnType.baseConcreteType->exportName + "\", ret);");
								codeSerializer.AddLine("break;");
							}
							codeSerializer.PopIndent();
							codeSerializer.AddLine("}");
						}
					}
					codeSerializer.AddLine("default: return uint32_t(prlrt::ExecutionError::FunctionNotFound);");
					codeSerializer.AddLine("}");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(e.type()) << 8);");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("} catch (...) {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::UnknownException) << 8);");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("}");
				codeSerializer.AddLine("");
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
			}
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_ContractCallEntry(void *pContractInstance, uint32_t functionId, const void **ptrs, uint32_t numPtrs) {");
		codeSerializer.PushIndent();
		{
			uint32_t numContractFunction = 0;
			for (size_t funcIdx = 0; funcIdx < m_exportedFunctions.size(); funcIdx++)
			{
				transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
				if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
					continue;
				transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];
				bool bIsContractFunction = (signature.flags & (uint32_t(transpiler::PredaFunctionFlags::CallableFromOtherContract))) != 0;
				if (bIsContractFunction)
					numContractFunction++;
			}

			if (numContractFunction == 0)
			{
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::CrossCallFunctionNotFound) << 8);");
			}
			else
			{
				codeSerializer.AddLine("try {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("switch (functionId){");
					for (size_t funcIdx = 0; funcIdx < m_exportedFunctions.size(); funcIdx++)
					{
						transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
						if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
							continue;
						transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];
						bool bIsContractFunction = (signature.flags & (uint32_t(transpiler::PredaFunctionFlags::CallableFromOtherContract))) != 0;
						if (bIsContractFunction)
						{
							codeSerializer.AddLine("case " + std::to_string(funcIdx) + ":");
							codeSerializer.AddLine("{");
							codeSerializer.PushIndent();
							{
								uint32_t numExpectedPtrs = uint32_t(signature.parameters.size()) + (signature.returnType.baseConcreteType != nullptr ? 1 : 0);
								codeSerializer.AddLine("if (numPtrs != " + std::to_string(numExpectedPtrs) + ") return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::CrossCallArgumentMismatch) << 8);");
								std::string line;
								if (signature.returnType.baseConcreteType != nullptr)
									line = "*(" + signature.returnType.baseConcreteType->outputFullName + " *)ptrs[numPtrs - 1] = ";
								line += "((" + m_currentContractOutputName + " *)pContractInstance)->" + curFunc.functionIdentifier->outputName + "(";
								for (size_t paramIdx = 0; paramIdx < signature.parameters.size(); paramIdx++)
									line += std::string(paramIdx > 0 ? ", " : "") + "*(" + signature.parameters[paramIdx]->qualifiedType.baseConcreteType->outputFullName + " *)ptrs[" + std::to_string(paramIdx) + "]";
								codeSerializer.AddLine(line + ");");
								codeSerializer.AddLine("break;");
							}
							codeSerializer.PopIndent();
							codeSerializer.AddLine("}");
						}
					}
					codeSerializer.AddLine("default: return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::CrossCallFunctionNotFound) << 8);");
					codeSerializer.AddLine("}");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(e.type()) << 8);");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("}");
				codeSerializer.AddLine("");
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
			}
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT void Contract_" + m_currentContractUniqueIdentifierStr + "_InitTables(uint64_t curContractId, uint64_t *importedContractIds) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("__prli___cur_contract_id = curContractId;");
			codeSerializer.AddLine("__prli___imported_contract_ids = importedContractIds;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT void* Contract_" + m_currentContractUniqueIdentifierStr + "_CreateInstance(prlrt::IRuntimeInterface *pInterface) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("prlrt::g_executionEngineInterface = pInterface;");
			codeSerializer.AddLine("return new " + m_currentContractOutputName + ";");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT void Contract_" + m_currentContractUniqueIdentifierStr + "_DestroyInstance(void *pContract) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("delete (" + m_currentContractOutputName + " *)pContract;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT bool Contract_" + m_currentContractUniqueIdentifierStr + "_MapContractContextToInstance(void *pInstance, prlrt::ContractContextType type, uint8_t *buffer, uint32_t bufferSize) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine(m_currentContractOutputName + " *pClassInst = (" + m_currentContractOutputName + " *)pInstance;");
			codeSerializer.AddLine("uint8_t *read_ptr = buffer;");
			codeSerializer.AddLine("prlrt::serialize_size_type readbuf_size = prlrt::serialize_size_type(bufferSize);");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("switch (type) {");

			transpiler::PredaDefinedVariableFlags perSectionFlags[] = { transpiler::PredaDefinedVariableFlags::ContextClassGlobal, transpiler::PredaDefinedVariableFlags::ContextClassShard, transpiler::PredaDefinedVariableFlags::ContextClassAddress };
			std::string perSectionEnum[] = { "Global", "PerShard", "PerAddress" };
			static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionEnum) / sizeof(perSectionEnum[0]), "state variable section metadata length doesn't match");

			constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

			for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
			{
				codeSerializer.AddLine("case prlrt::ContractContextType::" + perSectionEnum[sectionIdx] + ":");
				codeSerializer.PushIndent();
				{
					uint32_t numStateVar = 0;
					for (auto itor : m_definedStateVariables)
						if ((itor.second.flags & uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassMask)) == uint32_t(perSectionFlags[sectionIdx]))
							numStateVar++;
					if (numStateVar > 0)
						codeSerializer.AddLine("if (!prlrt::util_rip_struct_serialized_header(" + std::to_string(numStateVar) + ", read_ptr, readbuf_size)) return false;");

					for (auto itor : m_definedStateVariables)
					{
						// state variables are always non-const
						transpiler::DefinedIdentifier definedVariable = itor.second;

						if ((definedVariable.flags & uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassMask)) == uint32_t(perSectionFlags[sectionIdx]))
							codeSerializer.AddLine("if (!pClassInst->" + definedVariable.outputName + ".map_from_serialized_data(read_ptr, readbuf_size, false)) return false;");
					}
					codeSerializer.AddLine("if (readbuf_size != 0) return false;");
					codeSerializer.AddLine("return true;");
				}
				codeSerializer.PopIndent();
			}

			codeSerializer.AddLine("}");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("return false;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_GetContractContextSerializeSize(void *pInstance, prlrt::ContractContextType type) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine(m_currentContractOutputName + " *pClassInst = (" + m_currentContractOutputName + " *)pInstance;");
			codeSerializer.AddLine("uint32_t ret = 0;");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("switch (type) {");

			transpiler::PredaDefinedVariableFlags perSectionFlags[] = { transpiler::PredaDefinedVariableFlags::ContextClassGlobal, transpiler::PredaDefinedVariableFlags::ContextClassShard, transpiler::PredaDefinedVariableFlags::ContextClassAddress };
			std::string perSectionEnum[] = { "Global", "PerShard", "PerAddress" };
			static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionEnum) / sizeof(perSectionEnum[0]), "state variable section metadata length doesn't match");

			constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

			for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
			{
				codeSerializer.AddLine("case prlrt::ContractContextType::" + perSectionEnum[sectionIdx] + ":");
				codeSerializer.PushIndent();
				{
					uint32_t numStateVar = 0;
					for (auto itor : m_definedStateVariables)
					{
						// state variables are always non-const
						transpiler::DefinedIdentifier definedVariable = itor.second;

						if ((definedVariable.flags & uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassMask)) == uint32_t(perSectionFlags[sectionIdx]))
						{
							numStateVar++;
							codeSerializer.AddLine("ret += pClassInst->" + definedVariable.outputName + ".get_serialize_size();");
						}
					}
					if (numStateVar > 0)
						codeSerializer.AddLine("ret += " + std::to_string((numStateVar + 1) * 4) + ";");
					codeSerializer.AddLine("return ret;");
				}
				codeSerializer.PopIndent();
			}

			codeSerializer.AddLine("}");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("return ret;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_SerializeOutContractContext(void *pInstance, prlrt::ContractContextType type, uint8_t *buffer) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine(m_currentContractOutputName + " *pClassInst = (" + m_currentContractOutputName + " *)pInstance;");
			codeSerializer.AddLine("uint8_t *write_ptr = buffer;");
			codeSerializer.AddLine("prlrt::serialize_size_type item_size = 0;");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("try {");
			codeSerializer.PushIndent();
			{
				codeSerializer.AddLine("switch (type) {");

				transpiler::PredaDefinedVariableFlags perSectionFlags[] = { transpiler::PredaDefinedVariableFlags::ContextClassGlobal, transpiler::PredaDefinedVariableFlags::ContextClassShard, transpiler::PredaDefinedVariableFlags::ContextClassAddress };
				std::string perSectionEnum[] = { "Global", "PerShard", "PerAddress" };
				static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionEnum) / sizeof(perSectionEnum[0]), "state variable section metadata length doesn't match");

				constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

				for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
				{
					codeSerializer.AddLine("case prlrt::ContractContextType::" + perSectionEnum[sectionIdx] + ":");
					codeSerializer.PushIndent();
					{
						{
							uint32_t numStateVar = 0;
							for (auto itor : m_definedStateVariables)
								if ((itor.second.flags & uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassMask)) == uint32_t(perSectionFlags[sectionIdx]))
									numStateVar++;

							if (numStateVar > 0)
							{
								codeSerializer.AddLine("((uint32_t*)buffer)[0] = (" + std::to_string(numStateVar) + " << 4) | 3;");
								codeSerializer.AddLine("write_ptr = buffer + " + std::to_string((numStateVar + 1) * 4) + ";");
							}
						}

						{
							uint32_t numStateVar = 0;
							for (auto itor : m_definedStateVariables)
							{
								// state variables are always non-const
								transpiler::DefinedIdentifier definedVariable = itor.second;

								if ((definedVariable.flags & uint32_t(transpiler::PredaDefinedVariableFlags::ContextClassMask)) == uint32_t(perSectionFlags[sectionIdx]))
								{
									numStateVar++;
									codeSerializer.AddLine("item_size = pClassInst->" + definedVariable.outputName + ".get_serialize_size();"
										" pClassInst->" + definedVariable.outputName + ".serialize_out(write_ptr, false);"
										" write_ptr += item_size;"
										" ((uint32_t*)buffer)[" + std::to_string(numStateVar) +"] = uint32_t(write_ptr - buffer - " + std::to_string((numStateVar + 1) * 4) + ");");
								}
							}
						}
						codeSerializer.AddLine("break;");
					}
					codeSerializer.PopIndent();
				}
				codeSerializer.AddLine("default: return uint32_t(prlrt::ExecutionError::SerializeOutUnknownContextClass);");
				codeSerializer.AddLine("}");
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
			codeSerializer.PushIndent();
			{
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(e.type()) << 8);");
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("}");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
	}
	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");

	codeSerializer.AddLine("");
	codeSerializer.AddLine("}");
	codeSerializer.AddLine("");
}

void FunctionSignatureToExportMeta(PredaRealListener::ExportedFunctionMeta& meta, const std::string &name, const transpiler::FunctionSignature& sig)
{
	meta.doxygenComment = sig.doxygenComment;
	meta.flags = sig.flags;
	meta.name = name;
	for (size_t i = 0; i < sig.parameters.size(); i++)
	{
		std::string paramExportType;
		if (sig.parameters[i]->qualifiedType.bIsConst)
			paramExportType += "c ";
		paramExportType += sig.parameters[i]->qualifiedType.baseConcreteType->exportName;
		meta.parameterType.push_back(paramExportType);
		meta.parameterName.push_back(sig.parameters[i]->inputName);
	}
	meta.returnType = (sig.returnType.baseConcreteType ? sig.returnType.baseConcreteType->exportName : "");
	if (meta.returnType.length() > 0 && sig.returnType.bIsConst)
		meta.returnType = "c " + meta.returnType;
}

void PredaRealListener::GenerateExportFunctionMeta()
{
	for (auto &it : m_exportedFunctions)
	{
		if (!it.GetSignature())
			continue;
		ExportedFunctionMeta func;
		FunctionSignatureToExportMeta(func, it.functionIdentifier->inputName, *it.GetSignature());
		m_exportedFunctionsMeta.push_back(func);

	}
}

void PredaRealListener::GenerateExportInterface()
{
	m_exportedInterface.resize(m_definedInterfaces.size());
	for (size_t i = 0; i < m_definedInterfaces.size(); i++)
	{
		ConcreteTypePtr interfaceType = m_definedInterfaces[i];
		assert(interfaceType != nullptr);

		ExportedInterface &ei = m_exportedInterface[i];
		ei.name = interfaceType->inputName;
		ei.functions.resize(interfaceType->vInterfaceMemberFuncIndexMapping.size());
		for (size_t j = 0; j < interfaceType->vInterfaceMemberFuncIndexMapping.size(); j++)
		{
			transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->vInterfaceMemberFuncIndexMapping[j].first;
			ConcreteTypePtr funcType = pDefinedFunction->qualifiedType.baseConcreteType;
			assert(funcType && funcType->typeCategory == transpiler::ConcreteType::FunctionType);
			const transpiler::FunctionSignature& functionSignature = funcType->vOverloadedFunctions[interfaceType->vInterfaceMemberFuncIndexMapping[j].second];

			FunctionSignatureToExportMeta(ei.functions[j], pDefinedFunction->inputName, functionSignature);
		}
	}
}

void PredaRealListener::VerifyImplementedInterface(const std::vector<PredaParser::InterfaceRefContext*> refs)
{
	for (size_t implInterfaceIdx = 0; implInterfaceIdx < refs.size(); implInterfaceIdx++)
	{
		PredaParser::InterfaceRefContext* ctx = refs[implInterfaceIdx];
		ConcreteTypePtr contractType;
		if (ctx->contractName)
		{
			contractType = m_transpilerCtx.globalType->FindInnerConcreteType(ctx->contractName->getText());
			if (contractType == nullptr)
			{
				m_errorPortal.SetAnchor(ctx->contractName->start);
				m_errorPortal.AddIdentifierNotDefinedError(ctx->contractName->getText());
				continue;
			}
			contractType = contractType->realType;
		}
		else
			contractType = m_transpilerCtx.globalType->FindInnerConcreteType(m_currentContractName);

		assert(contractType);
		ConcreteTypePtr interfaceType = contractType->FindInnerConcreteType(ctx->interfaceName->getText());
		if (interfaceType == nullptr)
		{
			m_errorPortal.SetAnchor(ctx->interfaceName->start);
			m_errorPortal.AddIdentifierNotDefinedError(ctx->interfaceName->getText());
			continue;
		}

		ImplementedInterface ii;
		for (size_t interfaceFuncIdx = 0; interfaceFuncIdx < interfaceType->vInterfaceMemberFuncIndexMapping.size(); interfaceFuncIdx++)
		{
			transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->vInterfaceMemberFuncIndexMapping[interfaceFuncIdx].first;
			const std::string& interfaceFunctionName = pDefinedFunction->inputName;
			ConcreteTypePtr funcType = pDefinedFunction->qualifiedType.baseConcreteType;
			assert(funcType && funcType->typeCategory == transpiler::ConcreteType::FunctionType);
			const transpiler::FunctionSignature &interfaceFunctionSignature = funcType->vOverloadedFunctions[interfaceType->vInterfaceMemberFuncIndexMapping[interfaceFuncIdx].second];

			bool bFound = false;
			bool bReportNotFoundError = true;
			for (size_t declaredFunctionIdx = 0; declaredFunctionIdx < m_forwardDeclaredFunctions.size(); declaredFunctionIdx++)
			{
				const ForwardDeclaredContractFunction &declFunc = m_forwardDeclaredFunctions[declaredFunctionIdx];
				if (declFunc.declaredFunc.functionIdentifier->inputName != interfaceFunctionName)
					continue;
				const transpiler::FunctionSignature *pDeclaredFunctionSignature = declFunc.declaredFunc.GetSignature();
				if (!pDeclaredFunctionSignature)
					continue;
				if (interfaceFunctionSignature.returnType != pDeclaredFunctionSignature->returnType)
					continue;
				if (interfaceFunctionSignature.parameters.size() != pDeclaredFunctionSignature->parameters.size())
					continue;

				bool bSameParamList = true;
				for (size_t paramIdx = 0; paramIdx < interfaceFunctionSignature.parameters.size(); paramIdx++)
					if (interfaceFunctionSignature.parameters[paramIdx]->qualifiedType != pDeclaredFunctionSignature->parameters[paramIdx]->qualifiedType)
					{
						bSameParamList = false;
						break;
					}
				if (!bSameParamList)
					continue;

				if ((interfaceFunctionSignature.flags ^ pDeclaredFunctionSignature->flags) & (uint32_t(transpiler::PredaFunctionFlags::IsConst) | uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)))
				{
					m_errorPortal.SetAnchor(declFunc.ctx->start);
					m_errorPortal.AddFunctionConstnessOrContextClassNotMatchInterface(ctx->getText());
					bReportNotFoundError = false;
					break;
				}
				if ((pDeclaredFunctionSignature->flags & uint32_t(transpiler::PredaFunctionFlags::CallableFromOtherContract)) == 0)
				{
					m_errorPortal.SetAnchor(declFunc.ctx->start);
					m_errorPortal.AddInterfaceFunctionImplementedButNotPublic(ctx->getText());
					bReportNotFoundError = false;
					break;
				}

				for (size_t exportFuncIdx = 0; exportFuncIdx < m_exportedFunctions.size(); exportFuncIdx++)
				{
					if (m_exportedFunctions[exportFuncIdx] == declFunc.declaredFunc)
					{
						ii.functionIds.push_back(uint32_t(exportFuncIdx));
						bFound = true;
						break;
					}
				}

				if (!bFound)
				{
					m_errorPortal.SetAnchor(declFunc.ctx->start);
					m_errorPortal.AddInternalError("function defined as public but not found in export list. Probably compiler bug");
					bReportNotFoundError = false;
					break;
				}
			}

			if (!bFound && bReportNotFoundError)
			{
				std::string funcDef;
				if ((interfaceFunctionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask))== uint32_t(transpiler::PredaFunctionFlags::ContextClassShard))
					funcDef += "shard ";
				else if ((interfaceFunctionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::ContextClassMask)) == uint32_t(transpiler::PredaFunctionFlags::ContextClassGlobal))
					funcDef += "global ";

				if (interfaceFunctionSignature.returnType.baseConcreteType)
				{
					if (interfaceFunctionSignature.returnType.bIsConst)
						funcDef += "const ";
					funcDef += interfaceFunctionSignature.returnType.baseConcreteType->inputName + " ";
				}
				funcDef += interfaceFunctionName + "(";
				for (size_t paramIdx = 0; paramIdx < interfaceFunctionSignature.parameters.size(); paramIdx++)
				{
					if (paramIdx)
						funcDef += ", ";
					if (interfaceFunctionSignature.parameters[paramIdx]->qualifiedType.bIsConst)
						funcDef += "const ";
					funcDef += interfaceFunctionSignature.parameters[paramIdx]->qualifiedType.baseConcreteType->inputName;
				}
				funcDef += ")";
				if (interfaceFunctionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::IsConst))
					funcDef += " const";

				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddInterfaceFunctionNotImplemented(ctx->getText(), funcDef);
			}
		}

		if (ii.functionIds.size() == interfaceType->vInterfaceMemberFuncIndexMapping.size())		// size does not match if any function didn't find its implementation
		{
			ii.fullName = interfaceType->exportName;
			m_implementedInterfaces.push_back(ii);
		}
	}
}

void PredaRealListener::ReservedFunctions_PostFlagPropagate(const std::string &name, const transpiler::FunctionSignature &signature)
{
	if (name == "on_deploy" || name == "on_scaleout")
	{
		if (signature.flags & (uint32_t(transpiler::PredaFunctionFlags::BlockDependencyPayload) | uint32_t(transpiler::PredaFunctionFlags::BlockDependencyEntropy)))
		{
			m_errorPortal.AddReservedFunctionHasTooHighBlockDependencyError(name);
		}
		if (signature.flags & uint32_t(transpiler::PredaFunctionFlags::TransactionDependency))
		{
			m_errorPortal.AddReservedFunctionHasTransactionDependencyError(name);
		}
	}
}

void PredaRealListener::PropagateFunctionFlagAcrossCallingGraph()
{
	// propagate function flags across the calling graph
	std::set<transpiler::FunctionSignature*> sourceSet;
	for (auto itor : m_functionCallGraph.m_functionCallerSets)
		sourceSet.insert(itor.first);

	while (!sourceSet.empty())
	{
		std::set<transpiler::FunctionSignature*> nextIterationSourceSet;
		for (auto sourceItor : sourceSet)
		{
			uint32_t sourcePropagatableFlags = sourceItor->flags & uint32_t(transpiler::PredaFunctionFlags::PropagatableFlagsMask);
			auto& targetSet = m_functionCallGraph.m_functionCallerSets[sourceItor];
			for (auto targetItor : targetSet)
			{
				uint32_t tarPropagatableFlags = targetItor->flags & uint32_t(transpiler::PredaFunctionFlags::PropagatableFlagsMask);
				if ((sourcePropagatableFlags | tarPropagatableFlags) != tarPropagatableFlags)
				{
					targetItor->flags |= sourcePropagatableFlags;
					nextIterationSourceSet.insert(targetItor);
				}
			}
		}
		sourceSet = nextIterationSourceSet;
	}
}

void PredaRealListener::exitContractDefinition(PredaParser::ContractDefinitionContext *ctx)
{
	if (m_errorPortal.m_errors.size() == 0)
	{
		AUTO_POP_THIS_PTR_STACK;

		DefinePendingRelayLambdas();

		PropagateFunctionFlagAcrossCallingGraph();
	
		// check for entropy and relay coexist error in user-defined functions
		for (auto &itor : m_forwardDeclaredFunctions)
		{
			if (itor.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType)
			{
				const transpiler::FunctionSignature &signature = itor.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[itor.declaredFunc.overloadIndex];

				if ((signature.flags & uint32_t(transpiler::PredaFunctionFlags::BlockDependencyEntropy)) != 0
					&& (signature.flags & uint32_t(transpiler::PredaFunctionFlags::HasAnyRelayStatement)) != 0)
				{
					m_errorPortal.SetAnchor(itor.ctx->functionDeclaration()->identifier()->start);
					m_errorPortal.AddMinedDependencyWithRelayError();
					return;
				}

				if (itor.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->outerType->typeCategory == transpiler::ConcreteType::ContractType)
				{
					m_errorPortal.SetAnchor(itor.ctx->functionDeclaration()->identifier()->start);
					ReservedFunctions_PostFlagPropagate(itor.ctx->functionDeclaration()->identifier()->getText(), signature);
				}
			}
		}

		// check for entropy and relay coexist error in relay lambda functions
		for (size_t i = 0; i < m_pendingRelayLambdas.size(); i++)
		{
			transpiler::FunctionRef &func = m_exportedFunctions[m_pendingRelayLambdas[i].exportFuncSlot];
			if (func.functionIdentifier != nullptr && func.functionIdentifier->qualifiedType.baseConcreteType != nullptr && func.functionIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType)
			{
				const transpiler::FunctionSignature &signature = func.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[func.overloadIndex];
				if ((signature.flags & uint32_t(transpiler::PredaFunctionFlags::BlockDependencyEntropy)) != 0
					&& (signature.flags & uint32_t(transpiler::PredaFunctionFlags::HasAnyRelayStatement)) != 0)
				{
					m_errorPortal.SetAnchor(m_pendingRelayLambdas[i].pDefinitionCtx->start);
					m_errorPortal.AddMinedDependencyWithRelayError();
					return;
				}
				if (func.functionIdentifier->qualifiedType.baseConcreteType->outerType->typeCategory == transpiler::ConcreteType::ContractType)
				{
					m_errorPortal.SetAnchor(m_pendingRelayLambdas[i].pDefinitionCtx->start);
					ReservedFunctions_PostFlagPropagate(func.functionIdentifier->inputName, signature);
				}
			}
		}

		VerifyImplementedInterface(ctx->interfaceRef());

		if (m_errorPortal.m_errors.size() == 0)
		{
			codeSerializer.PopIndent();
			codeSerializer.AddLine("};");

			GenerateAuxiliaryFunctions();
			GenerateExportFunctionMeta();
			GenerateExportInterface();
		}
	}
}

void PredaRealListener::enterFunctionDefinition(PredaParser::FunctionDefinitionContext *ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global function definition is not supported yet, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	m_transpilerCtx.functionCtx.PushFunctionScope(thisType->CreateInnerUnnamedScopeType("function_" + ctx->functionDeclaration()->identifier()->getText()));

	auto itor = m_functionDefinitionContext2ForwardDeclaredFunctions.find(ctx);
	if (itor == m_functionDefinitionContext2ForwardDeclaredFunctions.end())			// forward declaration failed
		return;
		
	ForwardDeclaredContractFunction &forwardDeclaredFunc = m_forwardDeclaredFunctions[itor->second];
	transpiler::FunctionSignature functionSignature = forwardDeclaredFunc.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[forwardDeclaredFunc.declaredFunc.overloadIndex];

	m_transpilerCtx.functionCtx.functionRef = forwardDeclaredFunc.declaredFunc;

	m_transpilerCtx.thisPtrStack.Push(thisType, (functionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::IsConst)) != 0);

	//parameters
	std::vector<PredaParser::FunctionParameterContext *> vParamCtx = ctx->functionDeclaration()->functionParameterList()->functionParameter();
	for (size_t i = 0; i < vParamCtx.size(); i++)
	{
		// function parameters are defined in the current scope (function scope)
		bool bIsConst = (vParamCtx[i]->ConstantKeyword() != nullptr);
		ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(vParamCtx[i]->typeName());
		if (pType == nullptr)
			return;

		// Although we already checked this at forward declaration, defining the parameter in local scope could still fail. Because another identifier with the same name could be declared in the outer scope after the definition of this function
		if (DefineFunctionLocalVariable(pType, vParamCtx[i]->identifier(), bIsConst, 0) == nullptr)
			return;

		// Here there's no need to check parameter const qualifier for transaction and relay functions, it's already done at forward declaration
	}

	m_lastStatementInFunctionIsReturnStatement = false;

	{
		std::string line;
		if (functionSignature.returnType.baseConcreteType == nullptr)
		{
			line += "void";
		}
		else
		{
			if (functionSignature.returnType.bIsConst)
				line += "const ";
			line += functionSignature.returnType.baseConcreteType->outputFullName;
		}
		line += " " + forwardDeclaredFunc.declaredFunc.functionIdentifier->outputName + "(";
		for (size_t i = 0; i < functionSignature.parameters.size(); i++)
		{
			if (i > 0)
				line += ", ";
			if (functionSignature.parameters[i]->qualifiedType.bIsConst)
				line += "const ";
			line += functionSignature.parameters[i]->qualifiedType.baseConcreteType->outputFullName + " " + functionSignature.parameters[i]->outputName;
		}
		line += ")";
		if ((functionSignature.flags & uint32_t(transpiler::PredaFunctionFlags::IsConst)) != 0)
			line += " const";
		line += " { prlrt::burn_gas_function_call();";
		codeSerializer.AddLine(line);
		codeSerializer.PushIndent();
	}
}

void PredaRealListener::exitFunctionDefinition(PredaParser::FunctionDefinitionContext *ctx)
{
	assert(m_transpilerCtx.functionCtx.localScopes.size() == 1);

	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	// This could happen if the function failed forward declaration
	if (m_transpilerCtx.functionCtx.GetFunctionSignature() == nullptr)
		return;

	AUTO_POP_THIS_PTR_STACK;

	// If a function should return a value but is not
	// TODO: Check in a more sophisticated way: e.g. when both if-else block returns at the end, recognize that and do not throw an error
	if (m_transpilerCtx.functionCtx.GetFunctionSignature()->returnType.baseConcreteType != nullptr && !m_lastStatementInFunctionIsReturnStatement)
	{
		m_errorPortal.SetAnchor(ctx->stop);
		m_errorPortal.AddNoReturnFromFunctionWithReturnTypeError();
		return;
	}

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

ConcreteTypePtr PredaRealListener::GetTypeFromExportedTypeNameStrStream(std::stringstream &inoutStream)
{
	std::string baseTypeName;
	if (!(inoutStream >> baseTypeName))
		return nullptr;
	if (baseTypeName == "array")
	{
		ConcreteTypePtr elementType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (elementType == nullptr)
			return nullptr;
		std::vector<ConcreteTypePtr> templateParams(1, elementType);
		return m_transpilerCtx.GetBuiltInArrayType()->GetConcreteTypeFromTemplateParams(templateParams);
	}
	else if (baseTypeName == "map")
	{
		ConcreteTypePtr keyType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (keyType == nullptr)
			return nullptr;
		ConcreteTypePtr elementType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (elementType == nullptr)
			return nullptr;
		std::vector<ConcreteTypePtr> templateParams = { keyType, elementType };
		return m_transpilerCtx.GetBuiltInMapType()->GetConcreteTypeFromTemplateParams(templateParams);
	}
	else
	{
		size_t scopePos = baseTypeName.rfind(".");
		if (scopePos == std::string::npos)
			return m_transpilerCtx.globalType->FindInnerConcreteType(baseTypeName);

		std::string nonScopedTypeName = baseTypeName.substr(scopePos + 1);
		std::string contractFullName = baseTypeName.substr(0, scopePos);
		auto it = m_contractFullNameToImportName.find(contractFullName);
		if (it == m_contractFullNameToImportName.end())
			return nullptr;
		std::string contractAlias = it->second;
		ConcreteTypePtr contractType = m_transpilerCtx.globalType->FindInnerConcreteType(contractAlias);
		if (contractType == nullptr)
			return nullptr;
		ConcreteTypePtr ret = contractType->FindInnerConcreteType(nonScopedTypeName);
		if (ret == nullptr)
			return nullptr;

		return ret;
	}

	return nullptr;
}

ConcreteTypePtr PredaRealListener::GetTypeFromExportedTypeName(const char *typeName)
{
	std::stringstream inTypeNameStream(typeName);
	return GetTypeFromExportedTypeNameStrStream(inTypeNameStream);
}

void PredaPreCompileListener::enterPredaSource(PredaParser::PredaSourceContext *ctx)
{
	m_currentContractName = ctx->contractDefinition()->identifier()->getText();
	if(ctx->directive().size()){
		std::vector<PredaParser::DirectiveContext *> directive_vec = ctx->directive();
		for(auto it : directive_vec){
			if(it->importDirective())
				ProcessImportDirective(it->importDirective());
		}
	}
}

bool PredaPreCompileListener::ProcessImportDirective(const PredaParser::ImportDirectiveContext *ctx){
	std::string contractFullName;
	if (ctx->dAppName)
	{
		contractFullName = ctx->dAppName->getText() + "." + ctx->contractName->getText();
	}
	else
	{
		contractFullName = m_currentDAppName + "." + ctx->contractName->getText();
	}
	m_dependentContracts.push_back(contractFullName);
	return true;
}

