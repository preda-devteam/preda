#include "PredaRealListener.h"
#include "util.h"

class AutoPopFunctionContextLocalScopeStack {
public:
	transpiler::FunctionContext *pContext;
	AutoPopFunctionContextLocalScopeStack(transpiler::FunctionContext *inContext)
	{
		pContext = inContext;
	}
	~AutoPopFunctionContextLocalScopeStack()
	{
		if (pContext)
		{
			pContext->PopScope();
		}
	}
};

#define AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK AutoPopFunctionContextLocalScopeStack autoPopFunctionContextLocalScopeStack(&m_transpilerCtx.functionCtx);

class AutoPopThisPtrStack {
public:
	transpiler::ThisPtrStack *pThisPtrStack;
	AutoPopThisPtrStack(transpiler::ThisPtrStack *inStack)
	{
		pThisPtrStack = inStack;
	}
	~AutoPopThisPtrStack()
	{
		if (pThisPtrStack)
		{
			pThisPtrStack->Pop();
		}
	}
};

#define AUTO_POP_THIS_PTR_STACK AutoPopThisPtrStack autoPopThisPtrStack(&m_transpilerCtx.thisPtrStack);

using ConcreteTypePtr = transpiler::ConcreteTypePtr;

transpiler::DefinedIdentifierPtr PredaRealListener::DefineFunctionLocalVariable(ConcreteTypePtr pType, PredaParser::IdentifierContext *identifierCtx, bool bIsConst, uint32_t flags)
{
	m_errorPortal.SetAnchor(identifierCtx->start);
	return DefineFunctionLocalVariable(pType, identifierCtx->getText(), bIsConst, flags);
}

transpiler::DefinedIdentifierPtr PredaRealListener::DefineFunctionLocalVariable(ConcreteTypePtr pType, const std::string &identifierName, bool bIsConst, uint32_t flags)
{
	assert(pType != nullptr);
	assert(m_transpilerCtx.functionCtx.IsInsideFunction());

	if (!m_identifierHub.ValidateNewIdentifier(identifierName))
		return nullptr;

	ConcreteTypePtr outerType = m_transpilerCtx.functionCtx.localScopes.back().concreteType;

	transpiler::DefinedIdentifierPtr ret = outerType->DefineMemberVariable(pType, identifierName, flags, bIsConst, true, false);
	if (ret == nullptr)
	{
		m_errorPortal.AddInternalError("identifier \"" + identifierName + "\" cannot be defined, unknown error");
		return nullptr;
	}

	return ret;
}

static void GenerateCodeForInterfaceFunction(CodeSerializer& codeSerializer, int64_t contractImportSlot, uint32_t interfaceSlot, const std::string& name, const transpiler::FunctionSignature& functionSignature, uint32_t interfaceFunctionIdx)
{
	{
		std::string line;
		if (functionSignature.returnType.baseConcreteType == nullptr)
		{
			line += "void";
		}
		else
		{
			if (functionSignature.returnType.bIsConst)
				line += "const ";
			line += functionSignature.returnType.baseConcreteType->outputFullName;
		}
		line += " " + name + "(";
		for (size_t j = 0; j < functionSignature.parameters.size(); j++)
		{
			if (j > 0)
				line += ", ";
			// Note: Here always declare trampoline function parameters as const.
			//       User may pass a rvalue to the function, which a non-const lvalue reference cannot be bound to and generates a c++ compile error.
			//       The "const" will be later removed from the argument after passed down the cross-contract call pipeline.
			//if (functionSignature.parameters[i]->qualifiedType.bIsConst)
			line += "const ";
			line += functionSignature.parameters[j]->qualifiedType.baseConcreteType->outputFullName + " &" + functionSignature.parameters[j]->outputName;
		}
		line += ")";
		if ((functionSignature.flags & uint32_t(transpiler::FunctionFlags::IsConst)) != 0)
			line += " const";
		line += " {";
		codeSerializer.AddLine(line);
		codeSerializer.PushIndent();
	}

	{
		std::string line;
		if (functionSignature.returnType.baseConcreteType != nullptr)
			line = "return prlrt::interface_call<" + functionSignature.returnType.baseConcreteType->outputFullName + ">(";
		else
			line = "prlrt::interface_call_no_ret(";
		line += "contract_id, " + std::to_string(contractImportSlot) + ", " + std::to_string(interfaceSlot) + ", " + std::to_string(interfaceFunctionIdx);
		for (size_t j = 0; j < functionSignature.parameters.size(); j++)
			line += ", " + functionSignature.parameters[j]->outputName;
		line += ");";
		codeSerializer.AddLine(line);
	}

	{
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
		codeSerializer.AddLine("");
	}
}

ConcreteTypePtr PredaRealListener::ImportContractSymbols(transpiler::IContractSymbols *pContractSymbols, const std::string contractImportName)
{
	size_t contractImportSlot = m_importedContracts.size();

	std::string contractFullName = pContractSymbols->GetDAppName() + std::string(".") + pContractSymbols->GetContractName();

	// Shouldn't call ValidateNewTypeNameIdentifier(contractImportName) here because 
	// 1. It's generated by the compiler and should not have any conflict.
	// 2. Implicitly imported contract are given "__" prefix to avoid name conflict, and will fail the check.
	//if (!ValidateNewTypeNameIdentifier(contractImportName, line, pos))
	//{
	//	return false;
	//}

	ConcreteTypePtr contractType = m_transpilerCtx.globalType->CreateInnerContractType(contractImportName, contractFullName);
	if (contractType == nullptr)
	{
		m_errorPortal.AddInternalError("Cannot declare contract type for imported contract \"" + contractFullName + "\" as \"" + contractImportName + "\". Probably compiler bug.");
		return nullptr;
	}

	m_transpilerCtx.thisPtrStack.Push(contractType, false);
	AUTO_POP_THIS_PTR_STACK;

	codeSerializer.AddLine("struct " + contractType->outputFullName + " : public prlrt::interface_struct {");
	codeSerializer.PushIndent();
	codeSerializer.AddLine("using interface_struct::interface_struct;");		// inherit the constructors from base class

	// enums
	{
		uint32_t numEnumTypes = pContractSymbols->GetNumEnumTypes();
		for (uint32_t enumTypeIdx = 0; enumTypeIdx < numEnumTypes; enumTypeIdx++)
		{
			std::string enumTypeName = pContractSymbols->GetEnumTypeName(enumTypeIdx);
			if (!m_identifierHub.ValidateNewIdentifier(enumTypeName))
				return nullptr;
			ConcreteTypePtr enumType = contractType->CreateInnerEnumType(enumTypeName);
			m_transpilerCtx.thisPtrStack.Push(enumType, false);
			AUTO_POP_THIS_PTR_STACK;
			if (enumType == nullptr)
			{
				m_errorPortal.AddInternalError("enum type \"" + enumTypeName + "\" cannot be imported. Unknown error.");
				return nullptr;
			}
			std::string enumTypeOutputName = enumType->outputFullName.substr(enumType->outputFullName.rfind("::") + 2);
			codeSerializer.AddLine("enum class " + enumTypeOutputName + "__ : prlrt::enum_base_type {");
			codeSerializer.PushIndent();
			uint32_t numEnumerators = pContractSymbols->GetNumEnumerators(enumTypeIdx);
			if (numEnumerators > 65535)
			{
				m_errorPortal.AddTooManyEnumeratorsError();
				return nullptr;
			}
			for (uint32_t enumeratorIdx = 0; enumeratorIdx < numEnumerators; enumeratorIdx++)
			{
				if (!m_identifierHub.ValidateNewIdentifier(pContractSymbols->GetEnumerator(enumTypeIdx, enumeratorIdx)))
					return nullptr;
				transpiler::DefinedIdentifierPtr pEnumerator = enumType->DefineMemberVariable(enumType, pContractSymbols->GetEnumerator(enumTypeIdx, enumeratorIdx), 0, true, false, true);
				if (pEnumerator == nullptr)
					return nullptr;
				codeSerializer.AddLine(pEnumerator->outputName + " = " + std::to_string(enumeratorIdx) + (enumeratorIdx != numEnumerators - 1 ? "," : ""));
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("};");
			codeSerializer.AddLine("using " + enumTypeOutputName + " = prlrt::enum_wrapper<" + enumTypeOutputName + "__, " + std::to_string(numEnumerators) + ">;");
			codeSerializer.AddLine("");
		}
	}

	// structs
	{
		uint32_t numStructTypes = pContractSymbols->GetNumStructTypes();
		for (uint32_t structTypeIdx = 0; structTypeIdx < numStructTypes; structTypeIdx++)
		{
			std::string structTypeName = pContractSymbols->GetStructTypeName(structTypeIdx);
			if (!m_identifierHub.ValidateNewIdentifier(structTypeName))
				return nullptr;

			uint32_t numMembers = pContractSymbols->GetNumStructMembers(structTypeIdx);
			std::vector<ConcreteTypePtr> vMemberTypes;
			for (uint32_t memberIdx = 0; memberIdx < numMembers; memberIdx++)
			{
				std::string memberType = pContractSymbols->GetStructMemberType(structTypeIdx, memberIdx);
				vMemberTypes.push_back(GetTypeFromExportedTypeName(memberType.c_str()));
			}

			ConcreteTypePtr structType = contractType->CreateInnerUserDefinedStructType(structTypeName);
			if (structType == nullptr)
			{
				m_errorPortal.AddInternalError("struct type \"" + structTypeName + "\" cannot be imported. Unknown error.");
				return nullptr;
			}

			codeSerializer.AddLine("#define EXPAND_STRUCT_MEMBER_LIST\\");
			codeSerializer.PushIndent();

			transpiler::FunctionSignature constructorSignature;
			constructorSignature.returnType = transpiler::QualifiedConcreteType(structType, false, false);		// struct constructor returns a non-lvalue non-const instance
			constructorSignature.flags = uint32_t(transpiler::FunctionFlags::IsConst);
			// Default constructor with no parameters
			{
				bool res = structType->DefineMemberFunction("@constructor", constructorSignature, false) != nullptr;
				assert(res);
			}

			std::vector<std::string> vMemberTypeOutputName(numMembers);
			std::vector<std::string> vMemberOutputName(numMembers);
			for (uint32_t memberIdx = 0; memberIdx < numMembers; memberIdx++)
			{
				std::string memberName = pContractSymbols->GetStructMemberName(structTypeIdx, memberIdx);

				ConcreteTypePtr pType = vMemberTypes[memberIdx];
				if (pType == nullptr)
					return nullptr;
				transpiler::DefinedIdentifierPtr pMember = structType->DefineMemberVariable(pType, memberName, 0, false, true, false);
				if (pMember == nullptr)
					return nullptr;

				constructorSignature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(pType, true, true, memberName, 0));
				vMemberOutputName[memberIdx] = pMember->outputName;
				vMemberTypeOutputName[memberIdx] = pType->outputFullName;

				if (memberIdx > 0)
					codeSerializer.AddLine("SPLITTER\\");
				codeSerializer.AddLine("EXPAND_STRUCT_MEMBER((" + vMemberTypeOutputName[memberIdx] + "), " + vMemberOutputName[memberIdx] + ")" + (memberIdx < numMembers - 1 ? "\\" : ""));
			}

			if (numMembers > 0)
			{
				bool res = structType->DefineMemberFunction("@constructor", constructorSignature, false) != nullptr;
				assert(res);
			}

			codeSerializer.PopIndent();

			std::string structTypeOutputName = structType->outputFullName.substr(structType->outputFullName.rfind("::") + 2);

			codeSerializer.AddLine("#define STRUCT_MEMBER_COUNT " + std::to_string(numMembers));
			codeSerializer.AddLine("#define STRUCT_INTERNAL_NAME " + structTypeOutputName + "__");
			codeSerializer.AddLine("#define STRUCT_NAME " + structTypeOutputName);
			codeSerializer.AddLine("#include \"include/define_struct.h\"");
			codeSerializer.AddLine("");
		}
	}

	// interfaces
	{
		uint32_t numInterfaces = pContractSymbols->GetNumExportedInterfaces();
		for (uint32_t interfaceIdx = 0; interfaceIdx < numInterfaces; interfaceIdx++)
		{
			std::string interfaceName = pContractSymbols->GetExportedInterfaceName(interfaceIdx);
			if (!m_identifierHub.ValidateNewIdentifier(interfaceName))
				return nullptr;
			ConcreteTypePtr interfaceType = contractType->CreateInnerInterfaceType(interfaceName);

			{
				transpiler::FunctionSignature signature;

				//function return type
				signature.returnType = transpiler::QualifiedConcreteType(interfaceType, true, false);		// struct constructor returns a non-lvalue const instance

				signature.flags = uint32_t(transpiler::FunctionFlags::IsConst);

				// constructor with uint64 contract id
				signature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, true, "contract_id", 0));
				bool res = interfaceType->DefineMemberFunction("@constructor", signature, false) != nullptr;
				assert(res);

				// __id()
				res = res & interfaceType->DefineMemberFunction("__id", transpiler::FunctionSignature(
					transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, false),
					std::vector<transpiler::DefinedIdentifierPtr>(),
					uint32_t(transpiler::FunctionFlags::IsConst)
				), false) != nullptr;

				// __valid()
				res = res & interfaceType->DefineMemberFunction("__valid", transpiler::FunctionSignature(
					transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInBoolType(), true, false),
					std::vector<transpiler::DefinedIdentifierPtr>(),
					uint32_t(transpiler::FunctionFlags::IsConst)
				), false) != nullptr;
			}

			codeSerializer.AddLine("struct " + interfaceType->outputFullName.substr(interfaceType->outputFullName.rfind("::") + 2) + " : public prlrt::interface_struct {");
			codeSerializer.PushIndent();
			codeSerializer.AddLine("using interface_struct::interface_struct;");		// inherit the constructors from base class

			uint32_t numFunctions = pContractSymbols->GetNumExportedInterfaceFunctions(interfaceIdx);
			for (uint32_t functionIdx = 0; functionIdx < numFunctions; functionIdx++)
			{
				std::string functionName = pContractSymbols->GetExportedInterfaceFunctionName(interfaceIdx, functionIdx);
				m_transpilerCtx.functionCtx.PushFunctionScope(interfaceType->CreateInnerUnnamedScopeType("interface_function_declare_" + functionName));
				AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

				transpiler::FunctionSignature functionSignature;
				functionSignature.flags = pContractSymbols->GetExportedInterfaceFunctionFlag(interfaceIdx, functionIdx);

				uint32_t numParams = pContractSymbols->GetExportedInterfaceFunctionNumParameters(interfaceIdx, functionIdx);
				for (uint32_t paramIdx = 0; paramIdx < numParams; paramIdx++)
				{
					std::string paramType = pContractSymbols->GetExportedInterfaceFunctionParameterType(interfaceIdx, functionIdx, paramIdx);
					std::string paramName = pContractSymbols->GetExportedInterfaceFunctionParameterName(interfaceIdx, functionIdx, paramIdx);
					ConcreteTypePtr pType;
					bool bIsConst = false;
					if (paramType.length() >= 2 && paramType[0] == 'c' && paramType[1] == ' ')
					{
						pType = GetTypeFromExportedTypeName(paramType.c_str() + 2);
						bIsConst = true;
					}
					else
						pType = GetTypeFromExportedTypeName(paramType.c_str());
					if (pType == nullptr)
						return nullptr;
					if (DefineFunctionLocalVariable(pType, paramName, bIsConst, 0) == nullptr)
						return nullptr;
				}
				functionSignature.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

				{
					std::string returnType = pContractSymbols->GetExportedInterfaceFunctionReturnType(interfaceIdx, functionIdx);
					ConcreteTypePtr pType;
					bool bIsConst = false;
					if (returnType != "")
					{
						if (returnType.length() >= 2 && returnType[0] == 'c' && returnType[1] == ' ')
						{
							pType = GetTypeFromExportedTypeName(returnType.c_str() + 2);
							bIsConst = true;
						}
						else
							pType = GetTypeFromExportedTypeName(returnType.c_str());
						if (pType == nullptr)
							return nullptr;
					}
					else
						bIsConst = true;
					functionSignature.returnType = transpiler::QualifiedConcreteType(pType, bIsConst, false);
				}

				transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->DefineMemberFunction(functionName, functionSignature, false);
				if (pDefinedFunction == nullptr)
					return nullptr;

				GenerateCodeForInterfaceFunction(codeSerializer, int64_t(contractImportSlot), interfaceIdx, pDefinedFunction->outputName, functionSignature, functionIdx);
			}

			codeSerializer.AddLine("__prlt_bool __prli___valid() { return prlrt::contract_implements_interface(contract_id, " + std::to_string(contractImportSlot) + ", " + std::to_string(interfaceIdx) + "); }");

			codeSerializer.PopIndent();
			codeSerializer.AddLine("};");
		}
	}

	// functions
	{
		uint32_t numExportedFunctions = pContractSymbols->GetNumExportedFunctions();
		for (uint32_t functionIdx = 0; functionIdx < numExportedFunctions; functionIdx++)
		{
			uint32_t flags = pContractSymbols->GetExportedFunctionFlag(functionIdx);
			if ((flags & (uint32_t(transpiler::FunctionFlags::CallableFromOtherContract))) == 0)
				continue;

			std::string functionName = pContractSymbols->GetExportedFunctionName(functionIdx);

			assert(m_transpilerCtx.functionCtx.localScopes.size() == 0);
			m_transpilerCtx.functionCtx.localScopes.push_back(transpiler::FunctionContext::LocalScope(transpiler::FunctionContext::LocalScope::Scope_Function, contractType->CreateInnerUnnamedScopeType("function_" + functionName)));
			AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

			transpiler::FunctionSignature functionSignature;
			functionSignature.flags = flags;

			{
				ConcreteTypePtr type;
				transpiler::DefinedIdentifierPtr pIdentifier;
				if (m_identifierHub.FindExistingIdentifier(functionName, &type, &pIdentifier))
				{
					// not an overloaded function in the same scope
					if (!(pIdentifier != nullptr && pIdentifier->qualifiedType.baseConcreteType->outerType == contractType && pIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType))
						return nullptr;
				}
			}

			uint32_t numParams = pContractSymbols->GetExportedFunctionNumParameters(functionIdx);
			for (uint32_t paramIdx = 0; paramIdx < numParams; paramIdx++)
			{
				std::string paramType = pContractSymbols->GetExportedFunctionParameterType(functionIdx, paramIdx);
				std::string paramName = pContractSymbols->GetExportedFunctionParameterName(functionIdx, paramIdx);
				ConcreteTypePtr pType;
				bool bIsConst = false;
				if (paramType.length() >= 2 && paramType[0] == 'c' && paramType[1] == ' ')
				{
					pType = GetTypeFromExportedTypeName(paramType.c_str() + 2);
					bIsConst = true;
				}
				else
					pType = GetTypeFromExportedTypeName(paramType.c_str());
				if (pType == nullptr)
					return nullptr;
				if (DefineFunctionLocalVariable(pType, paramName, bIsConst, 0) == nullptr)
					return nullptr;
			}
			functionSignature.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

			{
				std::string returnType = pContractSymbols->GetExportedFunctionReturnType(functionIdx);
				ConcreteTypePtr pType;
				bool bIsConst = false;
				if (returnType != "")
				{
					if (returnType.length() >= 2 && returnType[0] == 'c' && returnType[1] == ' ')
					{
						pType = GetTypeFromExportedTypeName(returnType.c_str() + 2);
						bIsConst = true;
					}
					else
						pType = GetTypeFromExportedTypeName(returnType.c_str());
					if (pType == nullptr)
						return nullptr;
				}
				functionSignature.returnType = transpiler::QualifiedConcreteType(pType, bIsConst, false);
			}

			
			transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction(functionName, functionSignature, false);
			if (pDefinedFunction == nullptr)
				return nullptr;

			{
				std::string line;
				if (functionSignature.returnType.baseConcreteType == nullptr)
				{
					line += "void";
				}
				else
				{
					if (functionSignature.returnType.bIsConst)
						line += "const ";
					line += functionSignature.returnType.baseConcreteType->outputFullName;
				}
				line += " " + pDefinedFunction->outputName + "(";
				for (size_t i = 0; i < functionSignature.parameters.size(); i++)
				{
					if (i > 0)
						line += ", ";
					// Note: Here always declare trampoline function parameters as const.
					//       User may pass a rvalue to the function, which a non-const lvalue reference cannot be bound to and generates a c++ compile error.
					//       The "const" will be later removed from the argument after passed down the cross-contract call pipeline.
					//if (functionSignature.parameters[i]->qualifiedType.bIsConst)
						line += "const ";
					line += functionSignature.parameters[i]->qualifiedType.baseConcreteType->outputFullName + " &" + functionSignature.parameters[i]->outputName;
				}
				line += ") const {";
				codeSerializer.AddLine(line);
				codeSerializer.PushIndent();
			}

			{
				std::string line;
				if (functionSignature.returnType.baseConcreteType != nullptr)
					line = "return prlrt::cross_call<" + functionSignature.returnType.baseConcreteType->outputFullName + ">(";
				else
					line = "prlrt::cross_call_no_ret(";
				line += "contract_id, " + std::to_string(contractImportSlot) + ", " + std::to_string(functionIdx);
				for (size_t i = 0; i < functionSignature.parameters.size(); i++)
					line += ", " + functionSignature.parameters[i]->outputName;
				line += ");";
				codeSerializer.AddLine(line);
			}

			{
				codeSerializer.PopIndent();
				codeSerializer.AddLine("}");
				codeSerializer.AddLine("");
			}
		}
	}

	// contract type constructor, takes a single uint64 contract id
	{
		transpiler::FunctionSignature signature;

		//function return type
		signature.returnType = transpiler::QualifiedConcreteType(contractType, true, false);		// struct constructor returns a non-lvalue const instance

		signature.flags = uint32_t(transpiler::FunctionFlags::IsConst);

		// constructor with uint64 contract id
		signature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, true, "contract_id", 0));
		bool res = contractType->DefineMemberFunction("@constructor", signature, false) != nullptr;
		assert(res);
	}

	// __id()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__id", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
			), false);
		if (pDefinedFunction == nullptr)
			return nullptr;
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInIntegerType(64, false)->outputFullName + " __prli___id() { return contract_id; }");
	}

	// __valid()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__valid", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInBoolType(), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
			), false);
		if (pDefinedFunction == nullptr)
			return nullptr;
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInBoolType()->outputFullName + " __prli___valid()  { return prlrt::contract_has_template(contract_id, " + std::to_string(contractImportSlot) + "); }");
	}

	// __address()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__address", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInAddressType(), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
			), false);
		if (pDefinedFunction == nullptr)
			return nullptr;
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInAddressType()->outputFullName + " __prli___address() { " + m_transpilerCtx.GetBuiltInAddressType()->outputFullName + " ret; ret.SetAsContract(contract_id); return ret; }");
	}

	codeSerializer.PopIndent();
	codeSerializer.AddLine("};");

	// import contract constructor, this is the contract's constructor, not the contract type constructor
	// constructor import doesn't generate any code and only grabs its parameter list, hence comes last
	{
		std::vector<ConcreteTypePtr> paramTypes;
		int32_t onDeployFuncIdx = pContractSymbols->GetGlobalDeployFunctionExportIndex();
		if (onDeployFuncIdx != -1)
		{
			if (onDeployFuncIdx >= (int32_t)pContractSymbols->GetNumExportedFunctions())
				return nullptr;
			uint32_t numParams = pContractSymbols->GetExportedFunctionNumParameters(onDeployFuncIdx);
			paramTypes.resize(numParams);
			for (uint32_t paramIdx = 0; paramIdx < numParams; paramIdx++)
			{
				std::string paramTypeStr = pContractSymbols->GetExportedFunctionParameterType(onDeployFuncIdx, paramIdx);
				if (paramTypeStr.length() >= 2 && paramTypeStr[0] == 'c' && paramTypeStr[1] == ' ')
					paramTypes[paramIdx] = GetTypeFromExportedTypeName(paramTypeStr.c_str() + 2);
				else
					paramTypes[paramIdx] = GetTypeFromExportedTypeName(paramTypeStr.c_str());
				if (paramTypes[paramIdx] == nullptr)
					return nullptr;
			}
		}
		if (!m_expressionParser.AddImportedContract(contractType, paramTypes, uint32_t(contractImportSlot)))
			return nullptr;
	}

	return contractType;
}

bool PredaRealListener::ImportContract(const std::string &contractFullName)
{
	//already imported
	if (std::find(m_importedContracts.begin(), m_importedContracts.end(), contractFullName) != m_importedContracts.end())
		return true;
	//already failed import once
	if (m_failedImportContracts.find(contractFullName) != m_failedImportContracts.end())
		return false;

	transpiler::IContractSymbols *pContractSymbols = m_pContractSymbolDatabase->GetContractSymbols(contractFullName.c_str());
	if (pContractSymbols == nullptr)
	{
		m_failedImportContracts.emplace(contractFullName);
		return false;
	}

	uint32_t numImportedContracts = pContractSymbols->GetNumImportedContracts();
	for (uint32_t i = 0; i < numImportedContracts; i++)
	{
		std::string indirectlyImportedContractFullName = pContractSymbols->GetImportedContractFullName(i);
		if (!ImportContract(indirectlyImportedContractFullName))
		{
			m_failedImportContracts.emplace(contractFullName);
			return false;
		}
	}

	std::string importName = "__imported_" + std::to_string(m_importedContracts.size()) + "_" + pContractSymbols->GetDAppName() + std::string("_") + pContractSymbols->GetContractName();

	// This has to be assigned before 
	{
		bool res = m_contractFullNameToImportName.try_emplace(contractFullName, importName).second;
		assert(res);
	}

	ConcreteTypePtr importedContractType = ImportContractSymbols(pContractSymbols, importName);
	if (importedContractType == nullptr)
	{
		m_failedImportContracts.emplace(contractFullName);
		return false;
	}

	m_importedContracts.push_back(contractFullName);
	{
		bool res = m_importedContractsType.try_emplace(contractFullName, importedContractType).second;
		assert(res);
	}

	return true;
}

void PredaRealListener::ProcessImportDirective(const PredaParser::ImportDirectiveContext *ctx)
{
	std::string contractFullName;
	if (ctx->dAppName)
		contractFullName = ctx->dAppName->getText() + "." + ctx->contractName->getText();
	else
		contractFullName = m_currentDAppName + "." + ctx->contractName->getText();

	if (!ImportContract(contractFullName))
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddContractImportFailure(contractFullName);
		return;
	}
}

void PredaRealListener::ProcessDirectives(const std::vector<PredaParser::DirectiveContext *> &vDirectiveCtx)
{
	for (auto it : vDirectiveCtx)
	{
		if (it->importDirective())
			ProcessImportDirective(it->importDirective());
		else
			assert(0);
	}
	std::set<ConcreteTypePtr> hasAlias;
	for (auto it : vDirectiveCtx)
	{
		if (it->importDirective())
		{
			PredaParser::ImportDirectiveContext *ctx = it->importDirective();
			PredaParser::IdentifierContext *aliasCtx = ctx->alias != nullptr ? ctx->alias : ctx->contractName;
			std::string alias = aliasCtx->getText();
			if (!m_identifierHub.ValidateNewIdentifier(aliasCtx))
				continue;

			std::string contractFullName;
			if (ctx->dAppName)
				contractFullName = ctx->dAppName->getText() + "." + ctx->contractName->getText();
			else
				contractFullName = m_currentDAppName + "." + ctx->contractName->getText();

			if (m_importedContractsType.find(contractFullName) == m_importedContractsType.end())
				continue;

			if (m_transpilerCtx.globalType->CreateInnerAliasType(alias, m_importedContractsType[contractFullName]) == nullptr)
			{
				m_errorPortal.AddInternalError(aliasCtx->start, "Cannot create alias for imported contract. Probably a compiler error");
				continue;
			}
			hasAlias.insert(m_importedContractsType[contractFullName]);
		}
		else
		{
			assert(0);
		}
	}
	
	for (std::map<std::string, ConcreteTypePtr>::iterator iter = m_importedContractsType.begin(); iter != m_importedContractsType.end(); iter++)
	{
		if (hasAlias.find(iter->second) == hasAlias.end())
		{
			std::string contractName = iter->first.substr(iter->first.find('.') + 1);
			if (m_transpilerCtx.globalType->CreateInnerAliasType(contractName, iter->second) == nullptr)
			{
				m_errorPortal.AddInternalError("Cannot create alias for imported contract. Probably a compiler error");
				break;
			}
		}
	}
}

void PredaRealListener::enterPredaSource(PredaParser::PredaSourceContext *ctx)
{
	m_currentContractName = ctx->contractDefinition()->identifier()->getText();

	m_currentContractUniqueIdentifierStr = m_currentDAppName + "_" + m_currentContractName + "_" + std::to_string(m_currentDAppName.size());
	m_currentContractNamespace = "NS_" + m_currentContractUniqueIdentifierStr;

	codeSerializer.AddLine("namespace " + m_currentContractNamespace + " {");

	ProcessDirectives(ctx->directive());
	if (m_errorPortal.m_errors.size() > 0)
	{
		m_pWalker->SkipCurrentRuleSubtree();
		return;
	}
}

bool PredaRealListener::ProcessLocalVariableDeclaration(PredaParser::LocalVariableDeclarationContext *ctx, std::string &outRes)
{
	ConcreteTypePtr varType;

	if (ctx->typeNameOrAuto()->typeName())
	{
		varType = m_identifierHub.GetTypeFromTypeNameContext(ctx->typeNameOrAuto()->typeName());
		if (varType == nullptr)
			return false;
	}

	bool bIsConst = ctx->typeNameOrAuto()->ConstantKeyword() != nullptr;
	ExpressionParser::ExpressionResult expRes;
	if (ctx->expression())
	{
		if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
			return false;

		if (ctx->typeNameOrAuto()->AutoKeyword())
		{
			varType = expRes.type.baseConcreteType;
			if (expRes.type.bIsConst && expRes.type.baseConcreteType->IsConstTransitive())
				bIsConst = true;
		}
		else
		{
			if (varType != expRes.type.baseConcreteType)
			{
				std::tuple<transpiler::OperatorTypeBitMask, ConcreteTypePtr, ConcreteTypePtr> k = std::make_tuple(transpiler::OperatorTypeBitMask::AssignmentBit, varType, expRes.type.baseConcreteType);
				auto iter = m_transpilerCtx.opProcessor.m.find(k);
				if (iter != m_transpilerCtx.opProcessor.m.end())
				{
					expRes.text = varType->outputFullName + "(" + expRes.text + ")";
				}
				else
				{
					m_errorPortal.SetAnchor(((antlr4::tree::TerminalNode*)ctx->children[2])->getSymbol());
					m_errorPortal.AddTypeMismatchError(varType, expRes.type.baseConcreteType);
					return false;
				}
			}

			if (expRes.type.baseConcreteType->IsConstTransitive() && expRes.type.bIsConst && !bIsConst)
			{
				m_errorPortal.SetAnchor(((antlr4::tree::TerminalNode*)ctx->children[2])->getSymbol());
				m_errorPortal.AddAssignConstReferenceTypeToNonConstError(expRes.type.baseConcreteType);
				return false;
			}
		}
	}
	else
	{
		if (varType == nullptr)		// auto
		{
			m_errorPortal.SetAnchor(ctx->typeNameOrAuto()->start);
			m_errorPortal.AddAutoDeclarationWithoutInitializerError();
			return false;
		}
	}

	if (varType == m_transpilerCtx.thisPtrStack.stack[0].thisType)
	{
		m_errorPortal.SetAnchor(ctx->typeNameOrAuto()->start);
		m_errorPortal.AddUseCurrentContractTypeError();
	}

	transpiler::DefinedIdentifierPtr pDefinedVariable = DefineFunctionLocalVariable(varType, ctx->identifier(), bIsConst, 0);
	if (pDefinedVariable == nullptr)
		return false;

	outRes = pDefinedVariable->qualifiedType.baseConcreteType->outputFullName + " " + pDefinedVariable->outputName;
	if (ctx->expression())
		outRes += " = " + expRes.text;
	
	return true;
}

std::string PredaRealListener::ProcessDoxygen(PredaParser::DoxygenContext *ctx){
	if(ctx->DoxygenSingle().size() > 0){
		std::string singleLine;
		for(int i = 0; i < ctx->DoxygenSingle().size(); i++){
			singleLine += ctx->DoxygenSingle(i)->getText();
		}
		return singleLine;
	}
	return ctx->DoxygenMulti()->getText();

}

void PredaRealListener::enterVariableDeclarationStatement(PredaParser::VariableDeclarationStatementContext *ctx)
{
	std::string line;
	if (ProcessLocalVariableDeclaration(ctx->localVariableDeclaration(), line))
	{
		line += ";";
		codeSerializer.AddLine(line);
	}
}

void PredaRealListener::enterExpressionStatement(PredaParser::ExpressionStatementContext *ctx)
{
	ExpressionParser::ExpressionResult expRes;
	if (m_expressionParser.ParseExpression(ctx->expression(), expRes))
	{
		codeSerializer.AddLine(expRes.text + ";");
	}
}

void PredaRealListener::enterReturnStatement(PredaParser::ReturnStatementContext *ctx)
{
	if (!m_transpilerCtx.functionCtx.IsInsideFunction())
		return;

	transpiler::FunctionSignature *pSignature = m_transpilerCtx.functionCtx.GetFunctionSignature();

	if (!pSignature)
		return;

	if (pSignature->returnType.baseConcreteType == nullptr)
	{
		if (ctx->expression())
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddReturnValueFromFunctionWithoutReturnTypeError();
			return;
		}
		else
		{
			codeSerializer.AddLine("return;");
			return;
		}
	}
	else
	{
		if (!ctx->expression())
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddReturnWithoutValueFromFunctionWithReturnTypeError(pSignature->returnType.baseConcreteType);
			return;
		}

		ExpressionParser::ExpressionResult expRes;
		if (m_expressionParser.ParseExpression(ctx->expression(), expRes))
		{
			if (expRes.type.baseConcreteType != pSignature->returnType.baseConcreteType)
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddTypeMismatchError(pSignature->returnType.baseConcreteType, expRes.type.baseConcreteType);
				return;
			}
			if (!pSignature->returnType.bIsConst && expRes.type.bIsConst && expRes.type.baseConcreteType->IsConstTransitive())
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddAssignConstReferenceTypeToNonConstError(expRes.type.baseConcreteType);
				return;
			}
			codeSerializer.AddLine("return " + expRes.text + ";");
		}
	}
}

void PredaRealListener::enterIfWithBlock(PredaParser::IfWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_If, "if");

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.AddLine("if (" + expRes.text + ") {");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitIfWithBlock(PredaParser::IfWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PopScope();

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterElseWithBlock(PredaParser::ElseWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_Else, "else");

	codeSerializer.AddLine("else {");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitElseWithBlock(PredaParser::ElseWithBlockContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterElseIfWithBlock(PredaParser::ElseIfWithBlockContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_ElseIf, "elseif");

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.AddLine("else if (" + expRes.text + ") {");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitElseIfWithBlock(PredaParser::ElseIfWithBlockContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterWhileStatement(PredaParser::WhileStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_While, "while");

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.AddLine("while (" + expRes.text + ") { prlrt::burn_gas_loop();");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitWhileStatement(PredaParser::WhileStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterDoWhileStatement(PredaParser::DoWhileStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_DoWhile, "dowhile");

	codeSerializer.AddLine("do { prlrt::burn_gas_loop();");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitDoWhileStatement(PredaParser::DoWhileStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	ExpressionParser::ExpressionResult expRes;
	if (!m_expressionParser.ParseExpression(ctx->expression(), expRes))
		return;

	if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
	{
		m_errorPortal.SetAnchor(ctx->expression()->start);
		m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		return;
	}

	codeSerializer.PopIndent();
	codeSerializer.AddLine("} while (" + expRes.text + ");");
}

void PredaRealListener::enterForStatement(PredaParser::ForStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_For, "for");

	std::string codeOutput = "for (";

	//statement 1, either a variable declaration or expression
	if (ctx->localVariableDeclaration())
	{
		std::string res;
		if (!ProcessLocalVariableDeclaration(ctx->localVariableDeclaration(), res))
			return;

		codeOutput += res;
	}
	else if (ctx->firstExpression)
	{
		ExpressionParser::ExpressionResult expRes;
		if (!m_expressionParser.ParseExpression(ctx->firstExpression, expRes))
			return;
		codeOutput += expRes.text;
	}
	codeOutput += ";";

	// statement 2, an expression
	if (ctx->secondExpression)
	{
		ExpressionParser::ExpressionResult expRes;
		if (!m_expressionParser.ParseExpression(ctx->secondExpression, expRes))
			return;
		if (expRes.type.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType())
		{
			m_errorPortal.SetAnchor(ctx->secondExpression->start);
			m_errorPortal.AddBooleanExpressionExpectedError(expRes.type.baseConcreteType);
		}
		codeOutput += " " + expRes.text;
	}
	codeOutput += ";";

	// statement 3, an expression
	if (ctx->thirdExpression)
	{
		ExpressionParser::ExpressionResult expRes;
		if (!m_expressionParser.ParseExpression(ctx->thirdExpression, expRes))
			return;

		codeOutput += " " + expRes.text;
	}

	codeOutput += ") { prlrt::burn_gas_loop();";

	codeSerializer.AddLine(codeOutput);
	codeSerializer.PushIndent();
}

void PredaRealListener::exitForStatement(PredaParser::ForStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterUserBlockStatement(PredaParser::UserBlockStatementContext *ctx)
{
	m_transpilerCtx.functionCtx.PushAddtionalLocalScope(transpiler::FunctionContext::LocalScope::Scope_UserBlock, "userblock");

	codeSerializer.AddLine("{");
	codeSerializer.PushIndent();
}

void PredaRealListener::exitUserBlockStatement(PredaParser::UserBlockStatementContext *ctx)
{
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

void PredaRealListener::enterRelayStatement(PredaParser::RelayStatementContext *ctx)
{
	if (ctx->relayLambdaDefinition())
		m_pWalker->SkipCurrentRuleSubtree();

	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;
	assert(thisType != nullptr && thisType->typeCategory == transpiler::ConcreteType::ContractType);
	if (thisType == nullptr || thisType->typeCategory != transpiler::ConcreteType::ContractType || m_transpilerCtx.functionCtx.GetFunctionSignature() == nullptr)
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddInternalError(ctx->start, "relay / issue statement not available outside a contract function. Probably a compiler bug.");
		return;
	}

	RelayType relayType;
	transpiler::ScopeType expectedfuncScope = transpiler::ScopeType::None;
	bool bRelayNext = false;

	ExpressionParser::ExpressionResult targetScopeExpRes;
	if (ctx->relayType()->expression())
	{
		if (!m_expressionParser.ParseExpression(ctx->relayType()->expression(), targetScopeExpRes))
			return;

		m_transpilerCtx.functionCtx.GetFunctionSignature()->flags |= uint32_t(transpiler::FunctionFlags::HasRelayScopeStatement);

		relayType = RelayType::CustomScope;
		expectedfuncScope = ConcreteTypeToScopeType(targetScopeExpRes.type.baseConcreteType);
		if (expectedfuncScope == transpiler::ScopeType::None)
		{
			m_errorPortal.SetAnchor(ctx->relayType()->start);
			m_errorPortal.AddInvalidRelayTargetTypeError(targetScopeExpRes.type.baseConcreteType->inputName);
			return;
		}
	}
	else if (ctx->relayType()->ShardsKeyword())
	{
		m_transpilerCtx.functionCtx.GetFunctionSignature()->flags |= uint32_t(transpiler::FunctionFlags::HasRelayShardsStatement);
		if ((m_transpilerCtx.functionCtx.GetFunctionSignature()->flags & uint32_t(transpiler::ScopeType::Mask)) != uint32_t(transpiler::ScopeType::Global))
		{
			m_errorPortal.SetAnchor(ctx->relayType()->start);
			m_errorPortal.AddRelayShardsOutsideGlobalError();
			return;
		}
		relayType = RelayType::Shards;
		expectedfuncScope = transpiler::ScopeType::Shard;
	}
	else if (ctx->relayType()->GlobalKeyword())
	{
		m_transpilerCtx.functionCtx.GetFunctionSignature()->flags |= uint32_t(transpiler::FunctionFlags::HasRelayGlobalStatement);
		if ((m_transpilerCtx.functionCtx.GetFunctionSignature()->flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(transpiler::ScopeType::Global))
		{
			m_errorPortal.SetAnchor(ctx->relayType()->start);
			m_errorPortal.AddRelayGlobalFromGlobalError();
			return;
		}
		relayType = RelayType::Global;
		expectedfuncScope = transpiler::ScopeType::Global;
	}
	else if (ctx->relayType()->NextKeyword())
	{
		m_transpilerCtx.functionCtx.GetFunctionSignature()->flags |= uint32_t(transpiler::FunctionFlags::HasRelayScopeStatement);
		transpiler::ScopeType curFuncScopeType = transpiler::ScopeType(m_transpilerCtx.functionCtx.GetFunctionSignature()->flags & uint32_t(transpiler::ScopeType::Mask));
		switch (curFuncScopeType)
		{
		case transpiler::ScopeType::Shard:
			m_errorPortal.SetAnchor(ctx->relayType()->start);
			m_errorPortal.AddRelayNextFromShardError();
			return;
		case transpiler::ScopeType::Global:
			relayType = RelayType::Global;
			expectedfuncScope = curFuncScopeType;
			break;
		default:
			relayType = RelayType::CustomScope;
			expectedfuncScope = curFuncScopeType;
			break;
		}
		bRelayNext = true;
	}
	else
	{
		assert(0);
	}

	int32_t opCode = -1;
	std::string argumentsString;

	if (ctx->relayLambdaDefinition())
	{
		PredaParser::RelayLambdaDefinitionContext *lambdaDefCtx = ctx->relayLambdaDefinition();
		std::vector<PredaParser::RelayLambdaParameterContext*> parameterCtxs = lambdaDefCtx->relayLambdaParameter();

		std::vector<transpiler::QualifiedConcreteType> vParamType(parameterCtxs.size());
		argumentsString = "";
		for (size_t i = 0; i < parameterCtxs.size(); i++)
		{
			PredaParser::TypeNameOrAutoContext *type = parameterCtxs[i]->typeNameOrAuto();

			// type == nullptr means it's a push parameter, i.e. ^identifier
			if (type != nullptr && type->typeName())
			{
				vParamType[i].baseConcreteType = m_identifierHub.GetTypeFromTypeNameContext(type->typeName());
				if (vParamType[i].baseConcreteType == nullptr)
					return;
			}

			vParamType[i].bIsConst = (type != nullptr && type->ConstantKeyword() != nullptr);
			ExpressionParser::ExpressionResult expRes;
			if (type != nullptr)
			{
				if (!m_expressionParser.ParseExpression(parameterCtxs[i]->expression(), expRes))
					return;
			}
			else
			{
				if (!m_expressionParser.ParseIdentifierAsExpression(parameterCtxs[i]->identifier(), expRes))
					return;
			}

			if (type == nullptr || type->AutoKeyword())
			{
				vParamType[i].baseConcreteType = expRes.type.baseConcreteType;
				if (expRes.type.bIsConst && expRes.type.baseConcreteType->IsConstTransitive())
					vParamType[i].bIsConst = true;
			}
			else
			{
				if (vParamType[i].baseConcreteType != expRes.type.baseConcreteType)
				{
					m_errorPortal.SetAnchor(parameterCtxs[i]->expression()->start);
					m_errorPortal.AddTypeMismatchError(vParamType[i].baseConcreteType, expRes.type.baseConcreteType);
					return;
				}
				if (expRes.type.baseConcreteType->IsConstTransitive() && expRes.type.bIsConst && !vParamType[i].bIsConst)
				{
					m_errorPortal.SetAnchor(parameterCtxs[i]->expression()->start);
					m_errorPortal.AddAssignConstReferenceTypeToNonConstError(expRes.type.baseConcreteType);
					return;
				}
			}

			if (vParamType[i].bIsConst && (vParamType[i].baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
			{
				m_errorPortal.SetAnchor(parameterCtxs[i]->identifier()->start);
				m_errorPortal.AddRelayToFunctionWithConstMoveOnlyParamError();
				return;
			}
			if (relayType == RelayType::Shards && (vParamType[i].baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
			{
				m_errorPortal.SetAnchor(parameterCtxs[i]->identifier()->start);
				m_errorPortal.AddRelayShardsToFunctionWithMoveOnlyParamError();
				return;
			}
			if(vParamType[i].baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::CantBePassedToRelay))
			{
				m_errorPortal.SetAnchor(parameterCtxs[i]->identifier()->start);
				m_errorPortal.AddScatteredTypesAsRelayParamsError();
			}

			argumentsString += ", " + expRes.text;
		}

		opCode = (int32_t)DeclareRelayLambdaFunction(lambdaDefCtx, vParamType, relayType, expectedfuncScope, m_curFunc);
	}
	else
	{
		transpiler::DefinedIdentifierPtr pFunctionIdentifier = thisType->GetMember(ctx->identifier()->getText(), nullptr);
		if (pFunctionIdentifier == nullptr)
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddIdentifierNotDefinedError(ctx->identifier()->getText());
			return;
		}

		if (pFunctionIdentifier->qualifiedType.baseConcreteType->typeCategory != transpiler::ConcreteType::FunctionType)
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddRelayToNoneFunctionError(ctx->identifier()->getText());
			return;
		}

		int overloadFuncIndex = m_expressionParser.FindMatchingOverloadedFunction(pFunctionIdentifier->qualifiedType.baseConcreteType, ctx->functionCallArguments(), argumentsString);
		if (overloadFuncIndex == -1)
			return;
		if (argumentsString.size() != 0)
			argumentsString = ", " + argumentsString;

		transpiler::FunctionSignature &signature = pFunctionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[overloadFuncIndex];
		transpiler::ScopeType funcScope = transpiler::ScopeType(signature.flags & uint32_t(transpiler::ScopeType::Mask));
		if (funcScope != expectedfuncScope)
		{
			m_errorPortal.SetAnchor(ctx->start);
			m_errorPortal.AddRelayTargetAndFunctionScopeMismatchError(targetScopeExpRes.type.baseConcreteType->inputName, ctx->identifier()->getText(), util::ScopeTypeToString(funcScope));
			return;
		}
		for (size_t i = 0; i < signature.parameters.size(); i++)
		{
			const transpiler::DefinedIdentifierPtr &param = signature.parameters[i];
			if ((param->qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0 && param->qualifiedType.bIsConst)
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddRelayToFunctionWithConstMoveOnlyParamError();
				return;
			}
			if (relayType == RelayType::Shards && (param->qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
			{
				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddRelayShardsToFunctionWithMoveOnlyParamError();
				return;
			}
		}
		signature.flags |= uint32_t(transpiler::FunctionFlags::CallableFromRelay);

		transpiler::FunctionRef funcRef;
		funcRef.functionIdentifier = pFunctionIdentifier;
		funcRef.overloadIndex = (size_t)overloadFuncIndex;
		opCode = int32_t(ExportFunction(funcRef));

		if (opCode == -1)
		{
			m_errorPortal.AddInternalError(ctx->start, "relay target \"" + ctx->identifier()->getText() + "\" not exported. Probably a compiler bug.");
			return;
		}
	}

	if (bRelayNext)
	{
		codeSerializer.AddLine("prlrt::relay_next(" + std::to_string(opCode) + argumentsString + ");");
	}
	else
	{
		switch (relayType)
		{
		case RelayType::CustomScope:
			codeSerializer.AddLine("prlrt::relay(" + targetScopeExpRes.text + ", " + std::to_string(uint32_t(expectedfuncScope)) + ", " + std::to_string(opCode) + argumentsString + ");");
			break;
		case RelayType::Shards:
			codeSerializer.AddLine("prlrt::relay_shards(" + std::to_string(opCode) + argumentsString + ");");
			break;
		case RelayType::Global:
			codeSerializer.AddLine("prlrt::relay_global(" + std::to_string(opCode) + argumentsString + ");");
			break;
		default:
			assert(0);
		}
	}
}

size_t PredaRealListener::DeclareRelayLambdaFunction(PredaParser::RelayLambdaDefinitionContext *ctx, const std::vector<transpiler::QualifiedConcreteType> &paramTypes, RelayType type, transpiler::ScopeType scope, ForwardDeclaredContractFunction* base)
{
	transpiler::FunctionRef ref;
	m_exportedFunctions.push_back(ref);
	m_pendingRelayLambdas.emplace_back(ctx, paramTypes, type, scope, m_exportedFunctions.size() - 1, base);
	return m_exportedFunctions.size() - 1;
}

void PredaRealListener::enterContinueStatement(PredaParser::ContinueStatementContext *ctx)
{
	if (!m_transpilerCtx.functionCtx.IsInsideLoopBlock())
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddContinueOutsideLoopError();
		return;
	}

	codeSerializer.AddLine("continue;");
}

void PredaRealListener::enterBreakStatement(PredaParser::BreakStatementContext *ctx)
{
	if (!m_transpilerCtx.functionCtx.IsInsideLoopBlock())
	{
		m_errorPortal.SetAnchor(ctx->start);
		m_errorPortal.AddBreakOutsideLoopError();
		return;
	}

	codeSerializer.AddLine("break;");
}


void PredaRealListener::exitStatement(PredaParser::StatementContext *ctx)
{
	if (!ctx->userBlockStatement())
	{
		if (!m_transpilerCtx.functionCtx.IsInsideBranchBlock())
		{
			m_lastStatementInFunctionIsReturnStatement = (ctx->returnStatement() != nullptr);
		}
	}
}

bool PredaRealListener::ReservedFunctions_OnDeclare(PredaParser::FunctionDeclarationContext* ctx, std::string &name, transpiler::FunctionSignature &signature)
{
	bool bMustBeShard = false;
	bool bMustBeGlobal = false;
	bool bMustHaveSingleBoolParam = false;

	if (name == "on_deploy")
	{
		bMustBeGlobal = true;

		for (uint32_t i = 0; i < signature.parameters.size(); i++)
		{
			if ((signature.parameters[i]->qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
			{
				m_errorPortal.SetAnchor(ctx->functionParameterList()->functionParameter()[i]->typeName()->start);
				m_errorPortal.AddMoveOnlyParamOfTxnFunctionOrConstructorError();
				return false;
			}
		}

	}
	else if (name == "on_scaleout")
	{
		bMustBeShard = true;
		bMustHaveSingleBoolParam = true;
	}
	else
		return true;

	signature.flags |= uint32_t(transpiler::FunctionFlags::CallableFromSystem);

	m_errorPortal.SetAnchor(ctx->identifier()->start);
	if (bMustBeShard && transpiler::ScopeType(signature.flags & uint32_t(transpiler::ScopeType::Mask)) != transpiler::ScopeType::Shard)
	{
		m_errorPortal.AddReservedFunctionMustBeShardError(name);
		return false;
	}

	if (bMustBeGlobal && transpiler::ScopeType(signature.flags & uint32_t(transpiler::ScopeType::Mask)) != transpiler::ScopeType::Global)
	{
		m_errorPortal.AddReservedFunctionMustBeGlobalError(name);
		return false;
	}

	if (signature.returnType.baseConcreteType != nullptr)
	{
		m_errorPortal.AddReservedFunctionMayNotHaveReturnValueError(name);
		return false;
	}

	if (bMustHaveSingleBoolParam && (signature.parameters.size() != 1 || signature.parameters[0]->qualifiedType.baseConcreteType != m_transpilerCtx.GetBuiltInBoolType()))
	{
		m_errorPortal.AddReservedFunctionMustHaveSingleBooleanParameterError(name);
		return false;
	}

	if ((signature.flags & (uint32_t(transpiler::FunctionFlags::CallableFromTransaction) | uint32_t(transpiler::FunctionFlags::CallableFromOtherContract))) != 0)
	{
		m_errorPortal.AddReservedFunctionCannotBePublicOrExportError(name);
		return false;
	}

	return true;
}

void PredaRealListener::ReservedFunctions_PostExport(const std::string &name, const transpiler::FunctionSignature &signature, size_t exportIdx)
{
	int32_t *pTarget = nullptr;
	if (name == "on_deploy")
	{
		pTarget = &m_globalDeployFunctionExportIdx;
		if (*pTarget != -1)
		{
			m_errorPortal.AddMultipleConstructorError();
			return;
		}
	}
	else if (name == "on_scaleout")
		pTarget = &m_shardScaleOutFunctionExportIdx;

	if (pTarget != nullptr)
	{
		if (*pTarget != -1)
		{
			m_errorPortal.AddInternalError("reserved function " + name + " redefinition. Probably a compiler bug.");
			return;
		}

		*pTarget = (int32_t)exportIdx;
	}

	return;
}

transpiler::ScopeType GetScopeFromScopeCtx(PredaParser::ScopeContext* ctx)
{
	if (ctx->ShardKeyword())
		return transpiler::ScopeType::Shard;
	else if (ctx->GlobalKeyword())
		return transpiler::ScopeType::Global;
	else if (ctx->AddressKeyword())
		return transpiler::ScopeType::Address;
	else if (ctx->UintType())
	{
		std::string uintType = ctx->UintType()->getText();
		if (uintType == "uint32")
			return transpiler::ScopeType::Uint32;
		else if (uintType == "uint64")
			return transpiler::ScopeType::Uint64;
		else if (uintType == "uint96")
			return transpiler::ScopeType::None;			// uint96 scope not enabled at language level yet
		else if (uintType == "uint128")
			return transpiler::ScopeType::Uint128;
		else if (uintType == "uint160")
			return transpiler::ScopeType::None;			// uint160 scope not enabled at language level yet
		else if (uintType == "uint256")
			return transpiler::ScopeType::Uint256;
		else if (uintType == "uint512")
			return transpiler::ScopeType::Uint512;
	}

	return transpiler::ScopeType::None;
}

bool PredaRealListener::GenFunctionSignatureFromFunctionDeclareCtx(transpiler::FunctionSignature& outSig, PredaParser::FunctionDeclarationContext* declCtx)
{
	if (!declCtx)
		return false;

	//context-class specifier
	if (declCtx->scope())
	{
		transpiler::ScopeType scope = GetScopeFromScopeCtx(declCtx->scope());
		if (scope == transpiler::ScopeType::None)
		{
			m_errorPortal.AddInvalidScopeError(declCtx->scope()->getText());
			return false;
		}
		outSig.flags |= uint32_t(scope);
	}
	else
	{
		// defaults to global function
		outSig.flags |= uint32_t(transpiler::ScopeType::Global);
	}

	//function return type
	if (declCtx->functionReturnTypeName())
	{
		ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(declCtx->functionReturnTypeName()->typeName());
		if (pType == nullptr)
			return false;

		outSig.returnType = transpiler::QualifiedConcreteType(pType, declCtx->functionReturnTypeName()->ConstantKeyword() != nullptr, false);
	}
	else
		outSig.returnType = transpiler::QualifiedConcreteType(nullptr, true, false);

	//function name
	// not using IdentifierHub::ValidateNewIdentifier() here because functions could be overloaded and hence can reuse same name.
	std::string functionName = declCtx->identifier()->getText();
	if (functionName.find("__") != std::string::npos)
	{
		m_errorPortal.SetAnchor(declCtx->identifier()->start);
		m_errorPortal.AddIdentifierTwoUnderscoreError();
		return false;
	}
	//doxygen comment
	if (declCtx->doxygen()) {
		outSig.doxygenComment = ProcessDoxygen(declCtx->doxygen());
	}

	//access specifiers
	std::vector<PredaParser::AccessSpecifierContext*> accessSpecifiers = declCtx->accessSpecifier();
	for (size_t i = 0; i < accessSpecifiers.size(); i++)
	{
		std::string accessSpecifier = accessSpecifiers[i]->getText();
		if (accessSpecifiers[i]->ExportKeyword() != nullptr)
			outSig.flags |= uint32_t(transpiler::FunctionFlags::CallableFromTransaction);
		else if (accessSpecifiers[i]->PublicKeyword() != nullptr)
			outSig.flags |= uint32_t(transpiler::FunctionFlags::CallableFromOtherContract);
		else
			assert(0);
	}
	bool bIsTransactionFunction = (outSig.flags & uint32_t(transpiler::FunctionFlags::CallableFromTransaction)) != 0;

	//parameters
	std::vector<PredaParser::FunctionParameterContext*> vParamCtx = declCtx->functionParameterList()->functionParameter();
	for (size_t i = 0; i < vParamCtx.size(); i++)
	{
		// function parameters are defined in the current scope (function scope)
		bool bIsConst = (vParamCtx[i]->ConstantKeyword() != nullptr);
		ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(vParamCtx[i]->typeName());
		if (pType == nullptr)
			return false;

		if (bIsTransactionFunction && (pType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::MoveOnly)) != 0)
		{
			m_errorPortal.SetAnchor(vParamCtx[i]->typeName()->start);
			m_errorPortal.AddMoveOnlyParamOfTxnFunctionOrConstructorError();
			return false;
		}

		transpiler::DefinedIdentifierPtr pDefinedVariable = DefineFunctionLocalVariable(pType, vParamCtx[i]->identifier(), bIsConst, 0);
		if (pDefinedVariable == nullptr)
			return false;
	}
	outSig.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

	// const qualifier
	if (declCtx->ConstantKeyword() != nullptr)
		outSig.flags = outSig.flags | uint32_t(transpiler::FunctionFlags::IsConst);

	return true;
}

void PredaRealListener::ForwardDeclareFunction(PredaParser::FunctionDefinitionContext *ctx)
{
	PredaParser::FunctionDeclarationContext* declCtx = ctx->functionDeclaration();

	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global function definition is not supported yet, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	m_transpilerCtx.functionCtx.PushFunctionScope(thisType->CreateInnerUnnamedScopeType("forward_declare_" + declCtx->identifier()->getText()));
	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	transpiler::FunctionSignature functionSignature;

	if (!GenFunctionSignatureFromFunctionDeclareCtx(functionSignature, declCtx))
		return;

	std::string functionName = declCtx->identifier()->getText();
	{
		ConcreteTypePtr type;
		transpiler::DefinedIdentifierPtr pIdentifier;
		if (m_identifierHub.FindExistingIdentifier(functionName, &type, &pIdentifier))
		{
			// not an overloaded function in the same scope
			if (!(pIdentifier != nullptr 
				&& pIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType
				&& pIdentifier->qualifiedType.baseConcreteType->outerType == thisType))
			{
				m_errorPortal.SetAnchor(declCtx->identifier()->start);
				m_errorPortal.AddIdentifierRedefinitionError(functionName);
				return;
			}
		}
	}

	// reserved functions are only for contracts
	if (thisType->typeCategory == transpiler::ConcreteType::ContractType)
	{
		if (!ReservedFunctions_OnDeclare(declCtx, functionName, functionSignature))
			return;
	}

	transpiler::DefinedIdentifierPtr pDefinedFunction = thisType->DefineMemberFunction(functionName, functionSignature, false);
	if (pDefinedFunction == nullptr)
	{
		m_errorPortal.SetAnchor(declCtx->identifier()->start);
		m_errorPortal.AddFunctionRedefinitionError();
		return;
	}

	ForwardDeclaredContractFunction forwardDeclearedFunc;
	forwardDeclearedFunc.declaredFunc.functionIdentifier = pDefinedFunction;
	forwardDeclearedFunc.declaredFunc.overloadIndex = pDefinedFunction->qualifiedType.baseConcreteType->vOverloadedFunctions.size() - 1;
	forwardDeclearedFunc.ctx = ctx;
	m_forwardDeclaredFunctions.push_back(forwardDeclearedFunc);
	m_functionDefinitionContext2ForwardDeclaredFunctions.insert(std::make_pair(ctx, m_forwardDeclaredFunctions.size() - 1));

	// generate export signature
	bool bNeedToExport = (functionSignature.flags &
		(	uint32_t(transpiler::FunctionFlags::CallableFromRelay)
			| uint32_t(transpiler::FunctionFlags::CallableFromTransaction)
			| uint32_t(transpiler::FunctionFlags::CallableFromOtherContract) 
			| uint32_t(transpiler::FunctionFlags::CallableFromSystem))
		)
		!= 0;

	if (bNeedToExport)
	{
		size_t exportSlot = ExportFunction(forwardDeclearedFunc.declaredFunc);

		// reserved functions are only for contracts
		if (thisType->typeCategory == transpiler::ConcreteType::ContractType)
		{
			m_errorPortal.SetAnchor(declCtx->identifier()->start);
			ReservedFunctions_PostExport(functionName, functionSignature, exportSlot);
		}
	}
}

void PredaRealListener::DefineInterface(PredaParser::InterfaceDefinitionContext* ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global scope interface definition is not supported yet by the PREDA grammar, hence this should hold
	assert(thisType != nullptr);

	std::string interfaceTypeName = ctx->identifier()->getText();
	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;

	ConcreteTypePtr interfaceType = thisType->CreateInnerInterfaceType(interfaceTypeName);

	{
		transpiler::FunctionSignature signature;

		//function return type
		signature.returnType = transpiler::QualifiedConcreteType(interfaceType, true, false);		// struct constructor returns a non-lvalue const instance

		signature.flags = uint32_t(transpiler::FunctionFlags::IsConst);

		// constructor with uint64 contract id
		signature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, true, "contract_id", 0));
		bool res = interfaceType->DefineMemberFunction("@constructor", signature, false) != nullptr;
		assert(res);
	}

	// __id()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->DefineMemberFunction("__id", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
		), false);
	}

	// __valid()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->DefineMemberFunction("__valid", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInBoolType(), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
		), false);
	}

	std::vector<PredaParser::FunctionDeclarationContext*> functionDeclarations = ctx->functionDeclaration();
	for (uint32_t i = 0; i < uint32_t(functionDeclarations.size()); i++)
	{
		PredaParser::FunctionDeclarationContext* declCtx = functionDeclarations[i];
		m_transpilerCtx.functionCtx.PushFunctionScope(interfaceType->CreateInnerUnnamedScopeType("interface_function_declare_" + declCtx->identifier()->getText()));
		AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

		transpiler::FunctionSignature functionSignature;
		if (!GenFunctionSignatureFromFunctionDeclareCtx(functionSignature, declCtx))
			continue;

		std::string functionName = declCtx->identifier()->getText();
		transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->DefineMemberFunction(functionName, functionSignature, false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.SetAnchor(declCtx->identifier()->start);
			m_errorPortal.AddFunctionRedefinitionError();
			continue;
		}
	}

	m_definedInterfaces.emplace_back(interfaceType);
}

size_t PredaRealListener::ExportFunction(transpiler::FunctionRef functionRef)
{
	for (size_t i = 0; i < m_exportedFunctions.size(); i++)
	{
		if (m_exportedFunctions[i].functionIdentifier == functionRef.functionIdentifier && m_exportedFunctions[i].overloadIndex == functionRef.overloadIndex)
			return i;
	}

	m_exportedFunctions.push_back(functionRef);

	return m_exportedFunctions.size() - 1;
}

void PredaRealListener::DefineStateVariable(PredaParser::StateVariableDeclarationContext *ctx)
{
	//context-class specifier
	uint32_t flags = 0;
	if (ctx->scope())
	{
		transpiler::ScopeType scope = GetScopeFromScopeCtx(ctx->scope());
		if (scope == transpiler::ScopeType::None)
		{
			m_errorPortal.AddInvalidScopeError(ctx->scope()->getText());
			return;
		}
		flags |= uint32_t(scope);
	}
	else
	{
		// defaults to global
		flags |= uint32_t(transpiler::ScopeType::Global);
	}

	ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(ctx->typeName());
	if (pType == nullptr)
		return;

	if ((pType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::HasBlob)) != 0
		&& ((flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(transpiler::ScopeType::Global)))
	{
		m_errorPortal.SetAnchor(ctx->typeName()->start);
		m_errorPortal.AddBlobInGlobalStateVariableError();
		return;
	}

	if((pType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::GlobalAndShardOnly)) &&
		((flags & uint32_t(transpiler::ScopeType::Mask)) != uint32_t(transpiler::ScopeType::Global)) &&
		((flags & uint32_t(transpiler::ScopeType::Mask)) != uint32_t(transpiler::ScopeType::Shard)))
	{
		m_errorPortal.SetAnchor(ctx->typeName()->start);
		m_errorPortal.AddScatteredTypesScopeError();
	}

	assert(m_transpilerCtx.thisPtrStack.stack.size() > 0);

	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;
	
	// state variables are always non-const
	transpiler::DefinedIdentifierPtr pDefinedVariable = m_transpilerCtx.thisPtrStack.stack.back().thisType->DefineMemberVariable(pType, ctx->identifier()->getText(), flags, false, true, false);
	if (pDefinedVariable != nullptr){
		m_definedStateVariables.push_back(std::make_pair(ctx, *pDefinedVariable));
		if(pDefinedVariable->qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::IsScatteredType))
			DefineScatteredStateVariable(pDefinedVariable, ctx);
	}
}

void PredaRealListener::DefineConstVariable(PredaParser::ConstVariableDeclarationContext* ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;
	assert(thisType != nullptr);

	ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(ctx->typeName());
	if (pType == nullptr)
	{
		return;
	}

	if (pType->typeCategory != transpiler::ConcreteType::ValueType && pType->typeCategory != transpiler::ConcreteType::ReferenceType && pType->typeCategory != transpiler::ConcreteType::EnumType)
	{
		m_errorPortal.SetAnchor(ctx->typeName()->start);
		m_errorPortal.AddInvalidConstMemberVarTypeError();
		return;
	}

	ExpressionParser::ExpressionResult outResult;
	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()) || !m_expressionParser.ParseExpression(ctx->expression(), outResult, true))
		return;

	if(outResult.type.baseConcreteType != pType)
	{
		m_errorPortal.SetAnchor(ctx->typeName()->start);
		m_errorPortal.AddTypeMismatchError(outResult.type.baseConcreteType, pType);
	}

	transpiler::DefinedIdentifierPtr pDefinedVariable = m_transpilerCtx.thisPtrStack.stack.back().thisType->DefineMemberVariable(pType, ctx->identifier()->getText(), 0, true, false, false);
	if (pDefinedVariable != nullptr)
		m_identifierHub.AddConstMemberVar(pDefinedVariable, outResult.text);
}

void PredaRealListener::DefineStruct(PredaParser::StructDefinitionContext *ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global scope struct definition is not supported yet by the PREDA grammar, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	std::string structTypeName = ctx->identifier()->getText();
	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;

	if (ctx->variableDeclaration().size() == 0)
	{
		m_errorPortal.SetAnchor(ctx->identifier()->start);
		m_errorPortal.AddEmptyStructError();
		return;
	}
	// struct members cannot reference the struct type itself. Therefore their types are checked before defining the struct type.
	std::vector<ConcreteTypePtr> memberTypes;
	{
		std::vector<PredaParser::VariableDeclarationContext*> memberVariableDclarations = ctx->variableDeclaration();
		for (size_t i = 0; i < memberVariableDclarations.size(); i++)
		{
			ConcreteTypePtr memberType = m_identifierHub.GetTypeFromTypeNameContext(memberVariableDclarations[i]->typeName());
			if (nullptr != memberType && (memberType->nestingPropagatableFlags & (uint32_t)transpiler::PredaTypeNestingPropagatableFlags::CantBeContained)) {
				m_errorPortal.SetAnchor(memberVariableDclarations[i]->typeName()->start);
				m_errorPortal.AddScatteredMapDefinedinStructError();
			}
			memberTypes.push_back(memberType);
		}
	}

	// Register the struct type
	ConcreteTypePtr structType = thisType->CreateInnerUserDefinedStructType(structTypeName);
	if (structType == nullptr)
	{
		m_errorPortal.AddInternalError(ctx->identifier()->start, "struct type \"" + structTypeName + "\" cannot be defined. Unknown error.");
		return;
	}

	//doxygen comment
	if(ctx->doxygen()){
		structType->doxygenComment = ProcessDoxygen(ctx->doxygen());
	}

	m_transpilerCtx.thisPtrStack.Push(structType, false);
	AUTO_POP_THIS_PTR_STACK;

	std::vector<transpiler::DefinedIdentifierPtr> members;
	{
		std::vector<PredaParser::VariableDeclarationContext*> memberVariableDeclarations = ctx->variableDeclaration();
		for (size_t i = 0; i < memberVariableDeclarations.size(); i++)
		{
			ConcreteTypePtr pType = memberTypes[i];
			if (pType == nullptr)
				continue;

			if (!m_identifierHub.ValidateNewIdentifier(memberVariableDeclarations[i]->identifier()))
				continue;

			transpiler::DefinedIdentifierPtr pMember = structType->DefineMemberVariable(pType, memberVariableDeclarations[i]->identifier()->getText(), 0, false, true, false);
			if (pMember == nullptr)
			{
				m_errorPortal.AddInternalError(memberVariableDeclarations[i]->identifier()->start, "identifier \"" + memberVariableDeclarations[i]->identifier()->getText() + "\" already used. Probably a compile bug.");
				continue;
			}

			members.push_back(pMember);
		}
	}

	// Add a constructor function to functions, which takes all members as parameters
	{
		transpiler::FunctionSignature signature;

		//function return type
		signature.returnType = transpiler::QualifiedConcreteType(structType, false, false);		// struct constructor returns a non-lvalue non-const instance

		signature.flags = uint32_t(transpiler::FunctionFlags::IsConst);

		// Default constructor with no parameters
		{
			bool res = structType->DefineMemberFunction("@constructor", signature, false) != nullptr;
			assert(res);
		}

		// constructor with a list of initial member variable values as parameters
		if (members.size() > 0)
		{
			//parameters are just the struct members. All passed-in as const
			for (size_t i = 0; i < members.size(); i++)
				signature.parameters.push_back(transpiler::Allocator::New<transpiler::DefinedIdentifier>(members[i]->qualifiedType.baseConcreteType, true, true, members[i]->inputName, 0));

			bool res = structType->DefineMemberFunction("@constructor", signature, false) != nullptr;
			assert(res);
		}
	}

	m_definedStructs.push_back(std::make_pair(ctx, structType));
}

void PredaRealListener::DefineEnum(PredaParser::EnumDefinitionContext *ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global scope enum definition is not supported yet by the PREDA grammar, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	std::vector<PredaParser::IdentifierContext*> identifiers = ctx->identifier();
	if (!m_identifierHub.ValidateNewIdentifier(identifiers[0]))
		return;
	if (identifiers.size() > 65536)		//the first identifier is the type name, hence 65536 instead of 65535 here
	{
		m_errorPortal.SetAnchor(identifiers[0]->start);
		m_errorPortal.AddTooManyEnumeratorsError();
		return;
	}

	std::string enumTypeName = identifiers[0]->getText();

	ConcreteTypePtr enumType = thisType->CreateInnerEnumType(enumTypeName);
	if (enumType == nullptr)
	{
		m_errorPortal.AddInternalError(identifiers[0]->start, "enum type \"" + enumTypeName + "\" cannot be defined. Unknown error.");
		return;
	}

	m_transpilerCtx.thisPtrStack.Push(enumType, false);
	AUTO_POP_THIS_PTR_STACK;

	bool bNoError = true;
	std::vector<std::string> definedIdentifierNames;
	for (size_t i = 1; i < identifiers.size(); i++)
	{
		if (!m_identifierHub.ValidateNewIdentifier(identifiers[i]))
		{
			bNoError = false;
			continue;
		}

		if (enumType->DefineMemberVariable(enumType, identifiers[i]->getText(), 0, true, false, true) == nullptr)
		{
			m_errorPortal.AddInternalError(identifiers[i]->start, "identifier \"" + identifiers[i]->getText() + "\" already used. Probably compiler bug.");
			return;
		}
	}

	if (bNoError)
		m_definedEnums.push_back(std::make_pair(ctx, enumType));
}

void PredaRealListener::enterContractDefinition(PredaParser::ContractDefinitionContext *ctx)
{
	m_pWalker->SkipCurrentRuleSubtree();

	if (!m_identifierHub.ValidateNewIdentifier(ctx->identifier()))
		return;

	if(ctx->doxygen()){
		m_currentDoxygenComment = ProcessDoxygen(ctx->doxygen());
	}

	std::string contractFullName = m_currentDAppName + "." + m_currentContractName;
	if (m_pContractSymbolDatabase->ContractExists(m_currentDAppName.c_str(), m_currentContractName.c_str()))
	{
		m_errorPortal.SetAnchor(ctx->identifier()->start);
		m_errorPortal.AddContractNameAlreadyUsedError(contractFullName);
		return;
	}
	m_contractAliasToFullName.emplace(m_currentContractName, contractFullName);

	ConcreteTypePtr contractType = m_transpilerCtx.globalType->CreateInnerContractType(m_currentContractName, contractFullName);
	if (contractType == nullptr)
	{
		m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot declare contract type \"" + m_currentContractName + "\". Probably compiler bug.");
		return;
	}

	m_transpilerCtx.thisPtrStack.Push(contractType, false);

	m_currentContractOutputName = contractType->outputFullName;
	codeSerializer.AddLine("struct " + m_currentContractOutputName + " {");
	codeSerializer.PushIndent();
	codeSerializer.AddLine("uint64_t contract_id = 0;");		// id of the contract, initialized in CreateInstance()
	codeSerializer.AddLine("prlrt::__prlt___block __prli___block;");
	codeSerializer.AddLine("prlrt::__prlt___transaction __prli___transaction;");
	codeSerializer.AddLine("prlrt::__prlt___event __prli___event;");
	codeSerializer.AddLine("prlrt::__prlt___debug __prli___debug;");

	codeSerializer.AddLine("");
	for (uint32_t i = 0; i < uint32_t(m_importedContracts.size()); i++)
	{
		auto itor = m_importedContractsType.find(m_importedContracts[i]);
		if (itor != m_importedContractsType.end())
		{
			codeSerializer.AddLine(itor->second->outputFullName + " imported_contract_" + std::to_string(i) + ";");
		}
	}


	// We have a two pass algorithm for declaration and definitions in a contract
	// Here is the first pass that forward declares all struct types, functions, and defines all enumeration types and state variables 
	std::vector<PredaParser::ContractPartContext*> contractParts = ctx->contractPart();
	for (size_t i = 0; i < contractParts.size(); i++)
	{
		if (contractParts[i]->stateVariableDeclaration())
		{
			DefineStateVariable(contractParts[i]->stateVariableDeclaration());
		}
		else if (contractParts[i]->structDefinition())
		{
			DefineStruct(contractParts[i]->structDefinition());
		}
		else if (contractParts[i]->enumDefinition())
		{
			DefineEnum(contractParts[i]->enumDefinition());
		}
		else if (contractParts[i]->functionDefinition())
		{
			ForwardDeclareFunction(contractParts[i]->functionDefinition());
		}
		else if (contractParts[i]->interfaceDefinition())
		{
			DefineInterface(contractParts[i]->interfaceDefinition());
		}
		else if (contractParts[i]->constVariableDeclaration())
		{
			DefineConstVariable(contractParts[i]->constVariableDeclaration());
		}
	}

	// Generate code for enum types
	for (auto itor : m_definedEnums)
	{
		ContractEnum enumerate;
		std::vector<PredaParser::IdentifierContext*> identifiers = itor.first->identifier();
		enumerate.name = identifiers[0]->getText();

		ConcreteTypePtr enumType = contractType->FindInnerConcreteType(enumerate.name);
		if (enumType == nullptr)
			continue;

		std::string enumTypeOutputName = enumType->outputFullName.substr(enumType->outputFullName.rfind("::") + 2);
		if(itor.first->doxygen()){
			enumerate.doxygenComment = ProcessDoxygen(itor.first->doxygen());
		}

		enumerate.enumerators = std::vector<std::string>();
		m_exportedEnums.emplace_back(enumerate);

		codeSerializer.AddLine("enum class " + enumTypeOutputName + "__ : prlrt::enum_base_type {");
		codeSerializer.PushIndent();
		for (size_t i = 0; i < enumType->members.size(); i++)
		{
			codeSerializer.AddLine(enumType->members[i]->outputName + " = " + std::to_string(i) + ",");
			m_exportedEnums.back().enumerators.push_back(enumType->members[i]->inputName);
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("};");
		codeSerializer.AddLine("using " + enumTypeOutputName + " = prlrt::enum_wrapper<" + enumTypeOutputName + "__, " + std::to_string(identifiers.size() - 1) + ">;");
		codeSerializer.AddLine("");
	}

	// Generate code for struct types
	for (auto itor : m_definedStructs)
	{
		ConcreteTypePtr structType = itor.second;
		if (structType == nullptr)
			continue;

		m_exportedStructs.emplace_back();

		codeSerializer.AddLine("#define EXPAND_STRUCT_MEMBER_LIST\\");
		codeSerializer.PushIndent();

		std::string structTypeName = itor.first->identifier()->getText();
		std::string structDoxygenComment;
		if(itor.first->doxygen() != nullptr){
			structDoxygenComment = ProcessDoxygen(itor.first->doxygen());
		}

		m_exportedStructs.back().name = structTypeName;
		m_exportedStructs.back().doxygenComment = structDoxygenComment;
		std::string structTypeOutputName;
		{
			ConcreteTypePtr structType = contractType->FindInnerConcreteType(structTypeName);
			if (structType == nullptr)
				continue;
			structTypeOutputName = structType->outputFullName.substr(structType->outputFullName.rfind("::") + 2);
		}

		std::vector<transpiler::DefinedIdentifierPtr> memberVariables;
		for (size_t i = 0; i < structType->members.size(); i++)
		{
			if (structType->members[i]->qualifiedType.baseConcreteType->typeCategory != transpiler::ConcreteType::FunctionType)
				memberVariables.push_back(structType->members[i]);
		}
		for (size_t i = 0; i < memberVariables.size(); i++)
		{
			if (i > 0)
				codeSerializer.AddLine("SPLITTER\\");
			codeSerializer.AddLine("EXPAND_STRUCT_MEMBER((" + memberVariables[i]->qualifiedType.baseConcreteType->outputFullName + "), " + memberVariables[i]->outputName + ")" + (i < memberVariables.size() - 1 ? "\\" : ""));
			m_exportedStructs.back().members.emplace_back(memberVariables[i]->qualifiedType.baseConcreteType->exportName, memberVariables[i]->inputName);
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("#define STRUCT_MEMBER_COUNT " + std::to_string(memberVariables.size()));
		codeSerializer.AddLine("#define STRUCT_INTERNAL_NAME " + structTypeOutputName + "__");
		codeSerializer.AddLine("#define STRUCT_NAME " + structTypeOutputName);
		codeSerializer.AddLine("#include \"include/define_struct.h\"");

		// TODO: add a copy constructor for the struct and serialize its code

		codeSerializer.AddLine("");
	}

	// Generate code for interfaces
	for (uint32_t interfaceIdx = 0; interfaceIdx < uint32_t(m_definedInterfaces.size()); interfaceIdx++)
	{
		ConcreteTypePtr interfaceType = m_definedInterfaces[interfaceIdx];
		if (interfaceType == nullptr)
			continue;
		assert(interfaceType->typeCategory == transpiler::ConcreteType::InterfaceType);

		codeSerializer.AddLine("struct " + interfaceType->outputFullName.substr(interfaceType->outputFullName.rfind("::") + 2) + " : public prlrt::interface_struct {");
		codeSerializer.PushIndent();
		codeSerializer.AddLine("using interface_struct::interface_struct;");		// inherit the constructors from base class

		for (size_t i = 0; i < interfaceType->vInterfaceMemberFuncIndexMapping.size(); i++)
		{
			transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->vInterfaceMemberFuncIndexMapping[i].first;
			if (pDefinedFunction == nullptr)
				continue;
			ConcreteTypePtr funcType = pDefinedFunction->qualifiedType.baseConcreteType;
			assert(funcType && funcType->typeCategory == transpiler::ConcreteType::FunctionType);
			const transpiler::FunctionSignature & functionSignature = funcType->vOverloadedFunctions[interfaceType->vInterfaceMemberFuncIndexMapping[i].second];

			GenerateCodeForInterfaceFunction(codeSerializer, -1, interfaceIdx, pDefinedFunction->outputName, functionSignature, uint32_t(i));
		}
		codeSerializer.AddLine("__prlt_bool __prli___valid() { return prlrt::contract_implements_interface(contract_id, -1, " + std::to_string(interfaceIdx) + "); }");
		codeSerializer.PopIndent();
		codeSerializer.AddLine("};");
	}

	// Generate code for state variables
	{
		transpiler::ScopeType perSectionFlags[] = { transpiler::ScopeType::Global, transpiler::ScopeType::Shard, transpiler::ScopeType::Address, transpiler::ScopeType::Uint32, transpiler::ScopeType::Uint64,
													transpiler::ScopeType::Uint96, transpiler::ScopeType::Uint128, transpiler::ScopeType::Uint160, transpiler::ScopeType::Uint256, transpiler::ScopeType::Uint512 };
		std::string perSectionNames[] = { "global", "shard", "address", "uint32", "uint64", "uint96", "uint128", "uint160", "uint256", "uint512" };
		static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionNames) / sizeof(perSectionNames[0]), "state variable section metadata length doesn't match");

		constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

		for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
		{
			m_stateVariableSignature[uint8_t(perSectionFlags[sectionIdx])] = "struct";

			std::string signature;
			bool hasBlob = false;
			bool hasAsset = false;
			uint32_t numSectionVar = 0;
			std::string doxygenComment;
			m_stateVariableDoxygenComment[uint8_t(perSectionFlags[sectionIdx])] = std::vector<std::string>();
			for (auto itor : m_definedStateVariables)
			{
				// state variables are always non-const
				transpiler::DefinedIdentifier definedVariable = itor.second;

				if ((definedVariable.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(perSectionFlags[sectionIdx]))
				{
					if (itor.first->doxygen())
						m_stateVariableDoxygenComment[uint8_t(perSectionFlags[sectionIdx])].push_back(ProcessDoxygen(itor.first->doxygen()));
					else
						m_stateVariableDoxygenComment[uint8_t(perSectionFlags[sectionIdx])].push_back("");
					std::string line = definedVariable.qualifiedType.baseConcreteType->outputFullName + " " + definedVariable.outputName;
					line += ";";
					codeSerializer.AddLine(line);

					numSectionVar++;
					signature += " " + definedVariable.qualifiedType.baseConcreteType->exportName + " " + definedVariable.inputName;
					if ((definedVariable.qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::HasBlob)) != 0)
						hasBlob = true;
					if ((definedVariable.qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::HasAsset)) != 0)
						hasAsset = true;
				}
			}
			if (numSectionVar > 0)
				codeSerializer.AddLine("");

			m_stateVariableSignature[uint8_t(perSectionFlags[sectionIdx])] += " " + std::to_string(numSectionVar) + signature;
			m_stateVariableHasBlob[uint8_t(perSectionFlags[sectionIdx])] = hasBlob;
			m_stateVariableHasAsset[uint8_t(perSectionFlags[sectionIdx])] = hasAsset;
		}
	}

	// __id()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__id", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
		), false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot define built-in function __id() for contract. Probably compiler bug.");
			return;
		}
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInIntegerType(64, false)->outputFullName + " __prli___id() { return contract_id; }");
	}

	// __valid()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__valid", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInBoolType(), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
		), false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot define built-in function __id() for contract. Probably compiler bug.");
			return;
		}
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInBoolType()->outputFullName + " __prli___valid()  { return prlrt::contract_has_template(contract_id, -1); }");
	}

	// __address()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__address", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInAddressType(), true, false),
			std::vector<transpiler::DefinedIdentifierPtr>(),
			uint32_t(transpiler::FunctionFlags::IsConst)
		), false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot define built-in function __address() for contract. Probably compiler bug.");
			return;
		}
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInAddressType()->outputFullName + " __prli___address() { " + m_transpilerCtx.GetBuiltInAddressType()->outputFullName + " ret; ret.SetAsContract(contract_id); return ret; }");
	}

	// __mint()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__mint", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInTokenType(), false, false),
			{
				transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInIntegerType(64, false), true, true, "id", 0),
				transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInBigIntType(), true, true, "amount", 0)
			},
			uint32_t(transpiler::FunctionFlags::IsConst)
		), false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot define built-in function __mint() for contract. Probably compiler bug.");
			return;
		}
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInTokenType()->outputFullName + " __prli___mint(__prlt_uint64 id, __prlt_bigint amount) { return prlrt::mint(id, amount); }");
	}

	// __burn()
	{
		transpiler::DefinedIdentifierPtr pDefinedFunction = contractType->DefineMemberFunction("__burn", transpiler::FunctionSignature(
			transpiler::QualifiedConcreteType(m_transpilerCtx.GetBuiltInBoolType(), false, false),
			{ transpiler::Allocator::New<transpiler::DefinedIdentifier>(m_transpilerCtx.GetBuiltInTokenType(), true, true, "burn_token", 0) },
			uint32_t(transpiler::FunctionFlags::IsConst)
		), false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->identifier()->start, "Cannot define built-in function __burn() for contract. Probably compiler bug.");
			return;
		}
		codeSerializer.AddLine(m_transpilerCtx.GetBuiltInBoolType()->outputFullName + " __prli___burn(__prlt_token burn_token) { return prlrt::burn(burn_token); }");
	}

	TraverseAllFunctions();
}

void PredaRealListener::TraverseAllFunctions()
{
	// traverse global functions first
	for (ForwardDeclaredContractFunction &func : m_forwardDeclaredFunctions)
	{
		transpiler::FunctionSignature* pSig = func.declaredFunc.GetSignature();
		if (pSig && (pSig->flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(transpiler::ScopeType::Global))
		{
			PredaParseTreeWalker* oldWalker = m_pWalker;
			PredaParseTreeWalker newWalker;
			SetWalker(&newWalker);
			m_curFunc = &func;
			m_pWalker->walk(this, func.ctx);
			SetWalker(oldWalker);
		}
	}

	// propagate flags once so that HasRelayShardsStatement is propagated across the global functions, which will be used later to ensure that a non-global function is not calling a global function that relay@shards
	// Note that since HasRelayShardsStatement flag is only allowed on global functions, they cannot propagate through non-global functions, hence propagating right here is sufficient
	PropagateFunctionFlagAcrossCallingGraph();

	// traverse non-global functions
	for (ForwardDeclaredContractFunction& func : m_forwardDeclaredFunctions)
	{
		transpiler::FunctionSignature* pSig = func.declaredFunc.GetSignature();
		if (pSig && (pSig->flags & uint32_t(transpiler::ScopeType::Mask)) != uint32_t(transpiler::ScopeType::Global))
		{
			PredaParseTreeWalker* oldWalker = m_pWalker;
			PredaParseTreeWalker newWalker;
			SetWalker(&newWalker);
			m_curFunc = &func;
			m_pWalker->walk(this, func.ctx);
			SetWalker(oldWalker);
		}
	}
}

void PredaRealListener::DefineScatteredStateVariable(transpiler::DefinedIdentifierPtr pIdentifier, PredaParser::StateVariableDeclarationContext *ctx)
{
	uint16_t fixedSizeInByte = pIdentifier->qualifiedType.baseConcreteType->scatteredScopeKeySize;
	uint8_t slotId = 0;
	for(const auto& var : m_scatteredStateVariables)
	{
		if(var.pIdentifier->qualifiedType.baseConcreteType->scatteredScopeKeySize == fixedSizeInByte)
			++slotId;
	}
	if(slotId >= 16)
	{
		m_errorPortal.SetAnchor(ctx->typeName()->start);
		m_errorPortal.AddExceedScatteredTypesNumberLimitError();
		return;
	}
	m_scatteredStateVariables.push_back(ScatteredTypeDefinition{slotId, pIdentifier});
}

void PredaRealListener::DefinePendingRelayLambdas()
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global function definition is not supported yet, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	for (size_t i = 0; i < m_pendingRelayLambdas.size(); i++)
	{
		PendingRelayLambda &lambda = m_pendingRelayLambdas[i];
		PredaParser::RelayLambdaDefinitionContext *ctx = lambda.pDefinitionCtx;

		//function name
		std::string functionName = "__relaylambda_" + std::to_string(lambda.exportFuncSlot) + "_" + lambda.baseFunc->declaredFunc.functionIdentifier->inputName;
		m_curFunc = lambda.baseFunc;
		m_transpilerCtx.functionCtx.PushFunctionScope(thisType->CreateInnerUnnamedScopeType("function_" + functionName));
		AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

		transpiler::FunctionSignature functionSignature;

		functionSignature.flags = uint32_t(transpiler::FunctionFlags::CallableFromRelay);
		functionSignature.flags |= uint32_t(lambda.funcScope);
		functionSignature.returnType = transpiler::QualifiedConcreteType(nullptr, true, false);

		//parameters
		std::vector<PredaParser::RelayLambdaParameterContext*> vParamNameCtxs = lambda.pDefinitionCtx->relayLambdaParameter();
		for (size_t i = 0; i < vParamNameCtxs.size(); i++)
		{
			// function parameters are defined in the current scope (function scope)
			if (DefineFunctionLocalVariable(lambda.paramTypes[i].baseConcreteType, vParamNameCtxs[i]->identifier(), lambda.paramTypes[i].bIsConst, 0) == nullptr)
				return;
		}

		functionSignature.parameters = m_transpilerCtx.functionCtx.localScopes.back().concreteType->members;

		// const qualifier
		if (ctx->ConstantKeyword() != nullptr)
			functionSignature.flags = functionSignature.flags | uint32_t(transpiler::FunctionFlags::IsConst);

		transpiler::DefinedIdentifierPtr pDefinedFunction = thisType->DefineMemberFunction(functionName, functionSignature, false);
		if (pDefinedFunction == nullptr)
		{
			m_errorPortal.AddInternalError(ctx->start, "cannot define relay lambda function with name \"" + functionName + "\", the identifier is already used. Probably a bug in transpiler.");
			return;
		}

		m_exportedFunctions[lambda.exportFuncSlot].functionIdentifier = pDefinedFunction;
		m_exportedFunctions[lambda.exportFuncSlot].overloadIndex = pDefinedFunction->qualifiedType.baseConcreteType->vOverloadedFunctions.size() - 1;


		// Copy the function signature to the current scope on the stack. (return statement will rely on this info to check return type
		m_transpilerCtx.functionCtx.functionRef = m_exportedFunctions[lambda.exportFuncSlot];

		m_lastStatementInFunctionIsReturnStatement = false;

		m_transpilerCtx.thisPtrStack.Push(thisType, (functionSignature.flags & uint32_t(transpiler::FunctionFlags::IsConst)) != 0);
		AUTO_POP_THIS_PTR_STACK;

		{
			std::string line;
			if (functionSignature.returnType.baseConcreteType == nullptr)
			{
				line += "void";
			}
			else
			{
				line += functionSignature.returnType.baseConcreteType->outputFullName;
				if (!functionSignature.returnType.bIsConst)
					line += "&";
			}
			line += " " + pDefinedFunction->outputName + "(";
			for (size_t i = 0; i < functionSignature.parameters.size(); i++)
			{
				if (i > 0)
					line += ", ";
				if (functionSignature.parameters[i]->qualifiedType.bIsConst)
					line += "const ";
				line += functionSignature.parameters[i]->qualifiedType.baseConcreteType->outputFullName + " " + functionSignature.parameters[i]->outputName;
			}
			line += ")";
			if ((functionSignature.flags & uint32_t(transpiler::FunctionFlags::IsConst)) != 0)
				line += " const";
			line += " { prlrt::burn_gas_function_call();";
			codeSerializer.AddLine(line);
			codeSerializer.PushIndent();
		}

		PredaParseTreeWalker *oldWalker = m_pWalker;
		PredaParseTreeWalker newWalker;
		SetWalker(&newWalker);
		m_pWalker->walk(this, ctx);
		SetWalker(oldWalker);

		if (m_transpilerCtx.functionCtx.GetFunctionSignature()->returnType.baseConcreteType != nullptr && !m_lastStatementInFunctionIsReturnStatement)
		{
			m_errorPortal.SetAnchor(ctx->stop);
			m_errorPortal.AddNoReturnFromFunctionWithReturnTypeError();
			return;
		}

		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
	}
}

void PredaRealListener::GenerateAuxiliaryFunctions()
{
	codeSerializer.AddLine("");
	codeSerializer.AddLine("extern \"C\" {");
	codeSerializer.PushIndent();
	{
		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_TransactionCallEntry(void *pContractInstance, uint32_t functionId, const uint8_t *args, uint32_t args_size) {");
		codeSerializer.PushIndent();
		{
			uint32_t numTransactionOrRelayFunction = 0;
			for (size_t funcIdx = 0; funcIdx < m_exportedFunctions.size(); funcIdx++)
			{
				transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
				if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
					continue;
				transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];
				bool bIsTransactionOrRelayFunction = (signature.flags &
					(uint32_t(transpiler::FunctionFlags::CallableFromTransaction)
						| uint32_t(transpiler::FunctionFlags::CallableFromRelay)
						| uint32_t(transpiler::FunctionFlags::CallableFromSystem))
					) != 0;
				if (bIsTransactionOrRelayFunction)
					numTransactionOrRelayFunction++;
			}

			if (numTransactionOrRelayFunction == 0)
			{
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::FunctionNotFound);");
			}
			else
			{
				codeSerializer.AddLine("try {");
				codeSerializer.PushIndent();
				codeSerializer.AddLine("if (pContractInstance) ((" + m_currentContractOutputName + " *)pContractInstance)->__prli___transaction.import_supplied_tokens();");
				{
					codeSerializer.AddLine("switch (functionId){");
					for (size_t funcIdx = 0; funcIdx < m_exportedFunctions.size(); funcIdx++)
					{
						transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
						if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
							continue;
						transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];
						bool bIsTransactionOrRelayOrSystemFunction = (signature.flags & 
							(uint32_t(transpiler::FunctionFlags::CallableFromTransaction)
								| uint32_t(transpiler::FunctionFlags::CallableFromRelay)
								| uint32_t(transpiler::FunctionFlags::CallableFromSystem))
							) != 0;
						if (bIsTransactionOrRelayOrSystemFunction)
						{
							codeSerializer.AddLine("case " + std::to_string(funcIdx) + ":");
							codeSerializer.AddLine("{");
							codeSerializer.PushIndent();
							{
								for (size_t paramIdx = 0; paramIdx < signature.parameters.size(); paramIdx++)
								{
									codeSerializer.AddLine(signature.parameters[paramIdx]->qualifiedType.baseConcreteType->outputFullName + " arg" + std::to_string(paramIdx) + ";");
									// TODO: deep validate args (e.g. vector serialization buffer offset out-of-range, when user fakes an invalid transaction call)
									codeSerializer.AddLine("if (!arg" + std::to_string(paramIdx) + ".map_from_serialized_data(args, args_size, true)) return uint32_t(prlrt::ExecutionError::ArgumentDeserializationFailure);");
								}
								codeSerializer.AddLine("if (args_size != 0) return uint32_t(prlrt::ExecutionError::ArgumentDeserializationFailure);");

								std::string line = "if (pContractInstance) ";
								if (signature.returnType.baseConcreteType != nullptr)
								{
									codeSerializer.AddLine(line);
									codeSerializer.AddLine("{");
									codeSerializer.PushIndent();
									line = signature.returnType.baseConcreteType->outputFullName + " ret = ";
								}	
								line += "((" + m_currentContractOutputName + " *)pContractInstance)->" + curFunc.functionIdentifier->outputName + "(";
								for (size_t paramIdx = 0; paramIdx < signature.parameters.size(); paramIdx++)
									line += (paramIdx > 0 ? ", arg" : "arg") + std::to_string(paramIdx);
								codeSerializer.AddLine(line + ");");
								if (signature.returnType.baseConcreteType != nullptr)
								{
									codeSerializer.AddLine("prlrt::report_return_value(\"" + signature.returnType.baseConcreteType->exportName + "\", ret);");
									codeSerializer.PopIndent();
									codeSerializer.AddLine("}");
								}
								codeSerializer.AddLine("break;");
							}
							codeSerializer.PopIndent();
							codeSerializer.AddLine("}");
						}
					}
					codeSerializer.AddLine("default: return uint32_t(prlrt::ExecutionError::FunctionNotFound);");
					codeSerializer.AddLine("}");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(e.type()) << 8);");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("} catch (...) {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::UnknownException) << 8);");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("}");
				codeSerializer.AddLine("");
				codeSerializer.AddLine("if (pContractInstance) ((" + m_currentContractOutputName + " *)pContractInstance)->__prli___transaction.clear_supplied_tokens();");		// collect residual from the supplied tokens, this is only needed when transaction execution succeeds
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
			}
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_ContractCallEntry(void *pContractInstance, uint32_t functionId, const void **ptrs, uint32_t numPtrs) {");
		codeSerializer.PushIndent();
		{
			std::vector<uint32_t> contractFunctions;
			contractFunctions.reserve(m_exportedFunctions.size());
			for (size_t funcIdx = 0; funcIdx < m_exportedFunctions.size(); funcIdx++)
			{
				transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
				if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
					continue;
				transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];
				bool bIsContractFunction = (signature.flags & (uint32_t(transpiler::FunctionFlags::CallableFromOtherContract))) != 0;
				if (bIsContractFunction || funcIdx == m_globalDeployFunctionExportIdx)		// always allow constructor to be called from other contracts (TODO: maybe only enable it when on_deploy is declared as public)
					contractFunctions.push_back(uint32_t(funcIdx));
			}

			if (contractFunctions.size() == 0)
			{
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::CrossCallFunctionNotFound) << 8);");
			}
			else
			{
				codeSerializer.AddLine("try {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("switch (functionId){");

					for (uint32_t funcIdx : contractFunctions)
					{
						transpiler::FunctionRef &curFunc = m_exportedFunctions[funcIdx];
						if (curFunc.functionIdentifier == nullptr || curFunc.functionIdentifier->qualifiedType.baseConcreteType == nullptr)
							continue;
						transpiler::FunctionSignature &signature = curFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[curFunc.overloadIndex];

						codeSerializer.AddLine("case " + std::to_string(funcIdx) + ":");
						codeSerializer.AddLine("{");
						codeSerializer.PushIndent();
						{
							uint32_t numExpectedPtrs = uint32_t(signature.parameters.size()) + (signature.returnType.baseConcreteType != nullptr ? 1 : 0);
							codeSerializer.AddLine("if (numPtrs != " + std::to_string(numExpectedPtrs) + ") return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::CrossCallArgumentMismatch) << 8);");
							std::string line;
							if (signature.returnType.baseConcreteType != nullptr)
								line = "*(" + signature.returnType.baseConcreteType->outputFullName + " *)ptrs[numPtrs - 1] = ";
							line += "((" + m_currentContractOutputName + " *)pContractInstance)->" + curFunc.functionIdentifier->outputName + "(";
							for (size_t paramIdx = 0; paramIdx < signature.parameters.size(); paramIdx++)
								line += std::string(paramIdx > 0 ? ", " : "") + "*(" + signature.parameters[paramIdx]->qualifiedType.baseConcreteType->outputFullName + " *)ptrs[" + std::to_string(paramIdx) + "]";
							codeSerializer.AddLine(line + ");");
							codeSerializer.AddLine("break;");
						}
						codeSerializer.PopIndent();
						codeSerializer.AddLine("}");
					}
					codeSerializer.AddLine("default: return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(prlrt::ExceptionType::CrossCallFunctionNotFound) << 8);");
					codeSerializer.AddLine("}");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(e.type()) << 8);");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("}");
				codeSerializer.AddLine("");
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
			}
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		// currently does nothing
		codeSerializer.AddLine("API_EXPORT void Contract_" + m_currentContractUniqueIdentifierStr + "_InitTables() {");
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT void* Contract_" + m_currentContractUniqueIdentifierStr + "_CreateInstance(prlrt::IRuntimeInterface *pInterface, uint64_t curContractId, const uint64_t *importedContractIds, uint32_t numImportedContracts, uint64_t gas_limit) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("prlrt::RemainingGas = gas_limit;");
			codeSerializer.AddLine("if (numImportedContracts != " + std::to_string(m_importedContracts.size()) + ") return nullptr;");
			codeSerializer.AddLine("prlrt::g_executionEngineInterface = pInterface;");
			codeSerializer.AddMacroLine("#if !defined(__wasm32__) && !defined(__APPLE__)");
			codeSerializer.AddLine(m_currentContractOutputName + " *ret = (" + m_currentContractOutputName + " *)prlrt::g_memory_pool.allocate(sizeof(" + m_currentContractOutputName + "));");
			codeSerializer.AddMacroLine("#else");
			codeSerializer.AddLine(m_currentContractOutputName + " *ret = new " + m_currentContractOutputName + ";");
			codeSerializer.AddMacroLine("#endif");
			codeSerializer.AddLine("ret = new (ret) " + m_currentContractOutputName + ";");
			codeSerializer.AddLine("if (ret) ret->contract_id = curContractId;");
			for (uint32_t i = 0; i < uint32_t(m_importedContracts.size()); i++)
			{
				auto itor = m_importedContractsType.find(m_importedContracts[i]);
				if (itor != m_importedContractsType.end())
				{
					codeSerializer.AddLine("ret->imported_contract_" + std::to_string(i) + ".contract_id = importedContractIds[" + std::to_string(i) + "];");
				}
			}
			for(auto& var : m_scatteredStateVariables)
			{
				transpiler::DefinedIdentifierPtr definedVariable = var.pIdentifier;
				codeSerializer.AddLine("ret->" + definedVariable->outputName + ".link_external_map(curContractId, " + std::to_string(definedVariable->flags - 1) + ", " + std::to_string(var.slotId) + ");");
			}
			codeSerializer.AddLine("return ret;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT void Contract_" + m_currentContractUniqueIdentifierStr + "_DestroyInstance(void *pContract) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("prlrt::disable_burn_gas();");
			codeSerializer.AddMacroLine("#if !defined(__wasm32__) && !defined(__APPLE__)");
			codeSerializer.AddLine("((" + m_currentContractOutputName + " *)pContract)->~" + m_currentContractOutputName + "();");
			codeSerializer.AddLine("prlrt::g_memory_pool.deallocate(pContract, sizeof(" + m_currentContractOutputName + "));");
			codeSerializer.AddMacroLine("#else");
			codeSerializer.AddLine("delete (" + m_currentContractOutputName + " *)pContract;");
			codeSerializer.AddMacroLine("#endif");
			codeSerializer.AddLine("prlrt::enable_burn_gas();");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT bool Contract_" + m_currentContractUniqueIdentifierStr + "_MapContractContextToInstance(void *pInstance, prlrt::ContractContextType type, const uint8_t *buffer, uint32_t bufferSize) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine(m_currentContractOutputName + " *pClassInst = (" + m_currentContractOutputName + " *)pInstance;");
			codeSerializer.AddLine("const uint8_t *read_ptr = buffer;");
			codeSerializer.AddLine("prlrt::serialize_size_type readbuf_size = prlrt::serialize_size_type(bufferSize);");
			codeSerializer.AddLine("try{");
			codeSerializer.PushIndent();
			{
				codeSerializer.AddLine("switch (type) {");

				transpiler::ScopeType perSectionFlags[] = { transpiler::ScopeType::Global, transpiler::ScopeType::Shard, transpiler::ScopeType::Address, transpiler::ScopeType::Uint32, transpiler::ScopeType::Uint64,
															transpiler::ScopeType::Uint96, transpiler::ScopeType::Uint128, transpiler::ScopeType::Uint160, transpiler::ScopeType::Uint256, transpiler::ScopeType::Uint512 };
				std::string perSectionEnum[] = { "Global", "Shard", "Address", "Uint32", "Uint64", "Uint96", "Uint128", "Uint160", "Uint256", "Uint512" };
				static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionEnum) / sizeof(perSectionEnum[0]), "state variable section metadata length doesn't match");

				constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

				for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
				{
					codeSerializer.AddLine("case prlrt::ContractContextType::" + perSectionEnum[sectionIdx] + ":");
					codeSerializer.PushIndent();
					{
						uint32_t numStateVar = 0;
						for (auto itor : m_definedStateVariables)
							if ((itor.second.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(perSectionFlags[sectionIdx]))
								numStateVar++;
						if (numStateVar > 0)
							codeSerializer.AddLine("if (!prlrt::util_rip_struct_serialized_header(" + std::to_string(numStateVar) + ", read_ptr, readbuf_size)) return false;");

						for (auto itor : m_definedStateVariables)
						{
							// state variables are always non-const
							transpiler::DefinedIdentifier definedVariable = itor.second;

							if ((definedVariable.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(perSectionFlags[sectionIdx]))
								codeSerializer.AddLine("if (!pClassInst->" + definedVariable.outputName + ".map_from_serialized_data(read_ptr, readbuf_size, false)) return false;");
						}
						codeSerializer.AddLine("if (readbuf_size != 0) return false;");
						codeSerializer.AddLine("return true;");
					}
					codeSerializer.PopIndent();
				}
				codeSerializer.AddLine("default:");
				codeSerializer.AddLine("    return false;");
				codeSerializer.AddLine("}");
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
			codeSerializer.PushIndent();
			codeSerializer.AddLine("return false;");
			codeSerializer.PopIndent();
			codeSerializer.AddLine("}");
			codeSerializer.AddLine("return false;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_GetContractContextSerializeSize(void *pInstance, prlrt::ContractContextType type) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine(m_currentContractOutputName + " *pClassInst = (" + m_currentContractOutputName + " *)pInstance;");
			codeSerializer.AddLine("uint32_t ret = 0;");
			codeSerializer.AddLine("try{");
			codeSerializer.PushIndent();
			{
				codeSerializer.AddLine("switch (type) {");

				transpiler::ScopeType perSectionFlags[] = { transpiler::ScopeType::Global, transpiler::ScopeType::Shard, transpiler::ScopeType::Address, transpiler::ScopeType::Uint32, transpiler::ScopeType::Uint64,
															transpiler::ScopeType::Uint96, transpiler::ScopeType::Uint128, transpiler::ScopeType::Uint160, transpiler::ScopeType::Uint256, transpiler::ScopeType::Uint512 };
				std::string perSectionEnum[] = { "Global", "Shard", "Address", "Uint32", "Uint64", "Uint96", "Uint128", "Uint160", "Uint256", "Uint512" };
				static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionEnum) / sizeof(perSectionEnum[0]), "state variable section metadata length doesn't match");

				constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

				for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
				{
					codeSerializer.AddLine("case prlrt::ContractContextType::" + perSectionEnum[sectionIdx] + ":");
					codeSerializer.PushIndent();
					{
						uint32_t numStateVar = 0;
						for (auto itor : m_definedStateVariables)
						{
							// state variables are always non-const
							transpiler::DefinedIdentifier definedVariable = itor.second;

							if ((definedVariable.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(perSectionFlags[sectionIdx]))
							{
								numStateVar++;
								codeSerializer.AddLine("ret += pClassInst->" + definedVariable.outputName + ".get_serialize_size();");
							}
						}
						if (numStateVar > 0)
							codeSerializer.AddLine("ret += " + std::to_string((numStateVar + 1) * 4) + ";");
						codeSerializer.AddLine("return ret;");
					}
					codeSerializer.PopIndent();
				}
				codeSerializer.AddLine("default:");
				codeSerializer.AddLine("    return ret;");
				codeSerializer.AddLine("}");
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
			codeSerializer.PushIndent();
			codeSerializer.AddLine("ret = 0xffffffff;");
			codeSerializer.PopIndent();
			codeSerializer.AddLine("}");
			codeSerializer.AddLine("return ret;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_SerializeOutContractContext(void *pInstance, prlrt::ContractContextType type, uint8_t *buffer) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine(m_currentContractOutputName + " *pClassInst = (" + m_currentContractOutputName + " *)pInstance;");
			codeSerializer.AddLine("uint8_t *write_ptr = buffer;");
			codeSerializer.AddLine("prlrt::serialize_size_type item_size = 0;");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("try {");
			codeSerializer.PushIndent();
			{
				codeSerializer.AddLine("switch (type) {");

				transpiler::ScopeType perSectionFlags[] = { transpiler::ScopeType::Global, transpiler::ScopeType::Shard, transpiler::ScopeType::Address, transpiler::ScopeType::Uint32, transpiler::ScopeType::Uint64,
															transpiler::ScopeType::Uint96, transpiler::ScopeType::Uint128, transpiler::ScopeType::Uint160, transpiler::ScopeType::Uint256, transpiler::ScopeType::Uint512 };
				std::string perSectionEnum[] = { "Global", "Shard", "Address", "Uint32", "Uint64", "Uint96", "Uint128", "Uint160", "Uint256", "Uint512" };
				static_assert(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]) == sizeof(perSectionEnum) / sizeof(perSectionEnum[0]), "state variable section metadata length doesn't match");

				constexpr uint32_t numOfSections = uint32_t(sizeof(perSectionFlags) / sizeof(perSectionFlags[0]));

				for (uint32_t sectionIdx = 0; sectionIdx < numOfSections; sectionIdx++)
				{
					codeSerializer.AddLine("case prlrt::ContractContextType::" + perSectionEnum[sectionIdx] + ":");
					codeSerializer.PushIndent();
					{
						{
							uint32_t numStateVar = 0;
							for (auto itor : m_definedStateVariables)
								if ((itor.second.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(perSectionFlags[sectionIdx]))
									numStateVar++;

							if (numStateVar > 0)
							{
								codeSerializer.AddLine("((uint32_t*)buffer)[0] = (" + std::to_string(numStateVar) + " << 4) | 3;");
								codeSerializer.AddLine("write_ptr = buffer + " + std::to_string((numStateVar + 1) * 4) + ";");
							}
						}

						{
							uint32_t numStateVar = 0;
							for (auto itor : m_definedStateVariables)
							{
								// state variables are always non-const
								transpiler::DefinedIdentifier definedVariable = itor.second;

								if ((definedVariable.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(perSectionFlags[sectionIdx]))
								{
									numStateVar++;
									codeSerializer.AddLine("item_size = pClassInst->" + definedVariable.outputName + ".get_serialize_size();"
										" pClassInst->" + definedVariable.outputName + ".serialize_out(write_ptr, false);"
										" write_ptr += item_size;"
										" ((uint32_t*)buffer)[" + std::to_string(numStateVar) +"] = uint32_t(write_ptr - buffer - " + std::to_string((numStateVar + 1) * 4) + ");");
								}
							}
						}
						codeSerializer.AddLine("break;");
					}
					codeSerializer.PopIndent();
				}
				codeSerializer.AddLine("default: return uint32_t(prlrt::ExecutionError::SerializeOutUnknownContextClass);");
				codeSerializer.AddLine("}");
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
			codeSerializer.PushIndent();
			{
				codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(e.type()) << 8);");
			}
			codeSerializer.PopIndent();
			codeSerializer.AddLine("}");
			codeSerializer.AddLine("");
			codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
		
		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_InitGasTable(uint16_t* gas_cost_tbl, uint8_t gas_tbl_size) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("prlrt::gas_costs = gas_cost_tbl;");
			codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("API_EXPORT uint64_t Contract_" + m_currentContractUniqueIdentifierStr + "_GetRemainingGas() {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("return prlrt::RemainingGas;");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_SetRemainingGas(uint64_t remainingGas) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine("prlrt::RemainingGas = remainingGas;");
			codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");

		codeSerializer.AddLine("API_EXPORT uint32_t Contract_" + m_currentContractUniqueIdentifierStr + "_CommitJournaledStates(void* pInstance, bool isGlobalContext) {");
		codeSerializer.PushIndent();
		{
			codeSerializer.AddLine(m_currentContractOutputName + " *pClassInst = (" + m_currentContractOutputName + " *)pInstance;");
			codeSerializer.AddLine("try{");
			{
				codeSerializer.PushIndent();
				codeSerializer.AddLine("if(isGlobalContext) {");
				{
					codeSerializer.PushIndent();
					for (auto itor : m_definedStateVariables)
					{
						transpiler::DefinedIdentifier definedVariable = itor.second;
						if (definedVariable.qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::IsScatteredType) &&
							((definedVariable.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(transpiler::ScopeType::Global)))
							codeSerializer.AddLine("pClassInst->" + definedVariable.outputName + ".commit_journaled_states();");
					}
					codeSerializer.PopIndent();
					codeSerializer.AddLine("}");
				}
				codeSerializer.AddLine("else {");
				{
					codeSerializer.PushIndent();
					for (auto itor : m_definedStateVariables)
					{
						transpiler::DefinedIdentifier definedVariable = itor.second;
						if (definedVariable.qualifiedType.baseConcreteType->nestingPropagatableFlags & uint32_t(transpiler::PredaTypeNestingPropagatableFlags::IsScatteredType) &&
							((definedVariable.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(transpiler::ScopeType::Shard)))
							codeSerializer.AddLine("pClassInst->" + definedVariable.outputName + ".commit_journaled_states();");
					}
					codeSerializer.PopIndent();
					codeSerializer.AddLine("}");
				}
				codeSerializer.PopIndent();
			}
			codeSerializer.AddLine("} catch (prlrt::preda_exception &e) {");
			{
				codeSerializer.PushIndent();
				{
					codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::RuntimeException) | (uint32_t(e.type()) << 8);");
				}
				codeSerializer.PopIndent();
				codeSerializer.AddLine("}");
			}
			codeSerializer.AddLine("");
			codeSerializer.AddLine("return uint32_t(prlrt::ExecutionError::NoError);");
		}
		codeSerializer.PopIndent();
		codeSerializer.AddLine("}");
	}
	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");

	codeSerializer.AddLine("");
	codeSerializer.AddLine("}");
	codeSerializer.AddLine("");
}

void FunctionSignatureToExportMeta(PredaRealListener::ExportedFunctionMeta& meta, const std::string &name, const transpiler::FunctionSignature& sig)
{
	meta.doxygenComment = sig.doxygenComment;
	meta.flags = sig.flags;
	meta.name = name;
	for (size_t i = 0; i < sig.parameters.size(); i++)
	{
		std::string paramExportType;
		if (sig.parameters[i]->qualifiedType.bIsConst)
			paramExportType += "c ";
		paramExportType += sig.parameters[i]->qualifiedType.baseConcreteType->exportName;
		meta.parameterType.push_back(paramExportType);
		meta.parameterName.push_back(sig.parameters[i]->inputName);
	}
	meta.returnType = (sig.returnType.baseConcreteType ? sig.returnType.baseConcreteType->exportName : "");
	if (meta.returnType.length() > 0 && sig.returnType.bIsConst)
		meta.returnType = "c " + meta.returnType;
}

void PredaRealListener::GenerateExportFunctionMeta()
{
	for (auto &it : m_exportedFunctions)
	{
		if (!it.GetSignature())
			continue;
		ExportedFunctionMeta func;
		FunctionSignatureToExportMeta(func, it.functionIdentifier->inputName, *it.GetSignature());
		m_exportedFunctionsMeta.push_back(func);

	}
}

void PredaRealListener::GenerateExportInterface()
{
	m_exportedInterface.resize(m_definedInterfaces.size());
	for (size_t i = 0; i < m_definedInterfaces.size(); i++)
	{
		ConcreteTypePtr interfaceType = m_definedInterfaces[i];
		assert(interfaceType != nullptr);

		ExportedInterface &ei = m_exportedInterface[i];
		ei.name = interfaceType->inputName;
		ei.functions.resize(interfaceType->vInterfaceMemberFuncIndexMapping.size());
		for (size_t j = 0; j < interfaceType->vInterfaceMemberFuncIndexMapping.size(); j++)
		{
			transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->vInterfaceMemberFuncIndexMapping[j].first;
			ConcreteTypePtr funcType = pDefinedFunction->qualifiedType.baseConcreteType;
			assert(funcType && funcType->typeCategory == transpiler::ConcreteType::FunctionType);
			const transpiler::FunctionSignature& functionSignature = funcType->vOverloadedFunctions[interfaceType->vInterfaceMemberFuncIndexMapping[j].second];

			FunctionSignatureToExportMeta(ei.functions[j], pDefinedFunction->inputName, functionSignature);
		}
	}
}

void PredaRealListener::VerifyImplementedInterface(const std::vector<PredaParser::InterfaceRefContext*> refs)
{
	for (size_t implInterfaceIdx = 0; implInterfaceIdx < refs.size(); implInterfaceIdx++)
	{
		PredaParser::InterfaceRefContext* ctx = refs[implInterfaceIdx];
		ConcreteTypePtr contractType;
		if (ctx->contractName)
		{
			contractType = m_transpilerCtx.globalType->FindInnerConcreteType(ctx->contractName->getText());
			if (contractType == nullptr)
			{
				m_errorPortal.SetAnchor(ctx->contractName->start);
				m_errorPortal.AddIdentifierNotDefinedError(ctx->contractName->getText());
				continue;
			}
			contractType = contractType->realType;
		}
		else
			contractType = m_transpilerCtx.globalType->FindInnerConcreteType(m_currentContractName);

		assert(contractType);
		ConcreteTypePtr interfaceType = contractType->FindInnerConcreteType(ctx->interfaceName->getText());
		if (interfaceType == nullptr)
		{
			m_errorPortal.SetAnchor(ctx->interfaceName->start);
			m_errorPortal.AddIdentifierNotDefinedError(ctx->interfaceName->getText());
			continue;
		}

		ImplementedInterface ii;
		for (size_t interfaceFuncIdx = 0; interfaceFuncIdx < interfaceType->vInterfaceMemberFuncIndexMapping.size(); interfaceFuncIdx++)
		{
			transpiler::DefinedIdentifierPtr pDefinedFunction = interfaceType->vInterfaceMemberFuncIndexMapping[interfaceFuncIdx].first;
			const std::string& interfaceFunctionName = pDefinedFunction->inputName;
			ConcreteTypePtr funcType = pDefinedFunction->qualifiedType.baseConcreteType;
			assert(funcType && funcType->typeCategory == transpiler::ConcreteType::FunctionType);
			const transpiler::FunctionSignature &interfaceFunctionSignature = funcType->vOverloadedFunctions[interfaceType->vInterfaceMemberFuncIndexMapping[interfaceFuncIdx].second];

			bool bFound = false;
			bool bReportNotFoundError = true;
			for (size_t declaredFunctionIdx = 0; declaredFunctionIdx < m_forwardDeclaredFunctions.size(); declaredFunctionIdx++)
			{
				const ForwardDeclaredContractFunction &declFunc = m_forwardDeclaredFunctions[declaredFunctionIdx];
				if (declFunc.declaredFunc.functionIdentifier->inputName != interfaceFunctionName)
					continue;
				const transpiler::FunctionSignature *pDeclaredFunctionSignature = declFunc.declaredFunc.GetSignature();
				if (!pDeclaredFunctionSignature)
					continue;
				if (interfaceFunctionSignature.returnType != pDeclaredFunctionSignature->returnType)
					continue;
				if (interfaceFunctionSignature.parameters.size() != pDeclaredFunctionSignature->parameters.size())
					continue;

				bool bSameParamList = true;
				for (size_t paramIdx = 0; paramIdx < interfaceFunctionSignature.parameters.size(); paramIdx++)
					if (interfaceFunctionSignature.parameters[paramIdx]->qualifiedType != pDeclaredFunctionSignature->parameters[paramIdx]->qualifiedType)
					{
						bSameParamList = false;
						break;
					}
				if (!bSameParamList)
					continue;

				if ((interfaceFunctionSignature.flags ^ pDeclaredFunctionSignature->flags) & (uint32_t(transpiler::FunctionFlags::IsConst) | uint32_t(transpiler::ScopeType::Mask)))
				{
					m_errorPortal.SetAnchor(declFunc.ctx->start);
					m_errorPortal.AddFunctionConstnessOrContextClassNotMatchInterfaceError(ctx->getText());
					bReportNotFoundError = false;
					break;
				}
				if ((pDeclaredFunctionSignature->flags & uint32_t(transpiler::FunctionFlags::CallableFromOtherContract)) == 0)
				{
					m_errorPortal.SetAnchor(declFunc.ctx->start);
					m_errorPortal.AddInterfaceFunctionImplementedButNotPublicError(ctx->getText());
					bReportNotFoundError = false;
					break;
				}

				for (size_t exportFuncIdx = 0; exportFuncIdx < m_exportedFunctions.size(); exportFuncIdx++)
				{
					if (m_exportedFunctions[exportFuncIdx] == declFunc.declaredFunc)
					{
						ii.functionIds.push_back(uint32_t(exportFuncIdx));
						bFound = true;
						break;
					}
				}

				if (!bFound)
				{
					m_errorPortal.SetAnchor(declFunc.ctx->start);
					m_errorPortal.AddInternalError("function defined as public but not found in export list. Probably compiler bug");
					bReportNotFoundError = false;
					break;
				}
			}

			if (!bFound && bReportNotFoundError)
			{
				std::string funcDef;
				if ((interfaceFunctionSignature.flags & uint32_t(transpiler::ScopeType::Mask))== uint32_t(transpiler::ScopeType::Shard))
					funcDef += "shard ";
				else if ((interfaceFunctionSignature.flags & uint32_t(transpiler::ScopeType::Mask)) == uint32_t(transpiler::ScopeType::Global))
					funcDef += "global ";

				if (interfaceFunctionSignature.returnType.baseConcreteType)
				{
					if (interfaceFunctionSignature.returnType.bIsConst)
						funcDef += "const ";
					funcDef += interfaceFunctionSignature.returnType.baseConcreteType->inputName + " ";
				}
				funcDef += interfaceFunctionName + "(";
				for (size_t paramIdx = 0; paramIdx < interfaceFunctionSignature.parameters.size(); paramIdx++)
				{
					if (paramIdx)
						funcDef += ", ";
					if (interfaceFunctionSignature.parameters[paramIdx]->qualifiedType.bIsConst)
						funcDef += "const ";
					funcDef += interfaceFunctionSignature.parameters[paramIdx]->qualifiedType.baseConcreteType->inputName;
				}
				funcDef += ")";
				if (interfaceFunctionSignature.flags & uint32_t(transpiler::FunctionFlags::IsConst))
					funcDef += " const";

				m_errorPortal.SetAnchor(ctx->start);
				m_errorPortal.AddInterfaceFunctionNotImplementedError(ctx->getText(), funcDef);
			}
		}

		if (ii.functionIds.size() == interfaceType->vInterfaceMemberFuncIndexMapping.size())		// size does not match if any function didn't find its implementation
		{
			ii.fullName = interfaceType->exportName;
			m_implementedInterfaces.push_back(ii);
		}
	}
}

void PredaRealListener::ReservedFunctions_PostFlagPropagate(const std::string &name, const transpiler::FunctionSignature &signature)
{
}

void PredaRealListener::PropagateFunctionFlagAcrossCallingGraph()
{
	// propagate function flags across the calling graph
	std::set<transpiler::FunctionSignature*> sourceSet;
	for (auto itor : m_functionCallGraph.m_functionCallerSets)
		sourceSet.insert(itor.first);

	while (!sourceSet.empty())
	{
		std::set<transpiler::FunctionSignature*> nextIterationSourceSet;
		for (auto sourceItor : sourceSet)
		{
			uint32_t sourcePropagatableFlags = sourceItor->flags & uint32_t(transpiler::FunctionFlags::PropagatableFlagsMask);
			auto& targetSet = m_functionCallGraph.m_functionCallerSets[sourceItor];
			for (auto targetItor : targetSet)
			{
				uint32_t tarPropagatableFlags = targetItor->flags & uint32_t(transpiler::FunctionFlags::PropagatableFlagsMask);
				if ((sourcePropagatableFlags | tarPropagatableFlags) != tarPropagatableFlags)
				{
					targetItor->flags |= sourcePropagatableFlags;
					nextIterationSourceSet.insert(targetItor);
				}
			}
		}
		sourceSet = nextIterationSourceSet;
	}
}

void PredaRealListener::exitContractDefinition(PredaParser::ContractDefinitionContext *ctx)
{
	if (m_errorPortal.m_errors.size() == 0)
	{
		AUTO_POP_THIS_PTR_STACK;

		DefinePendingRelayLambdas();

		PropagateFunctionFlagAcrossCallingGraph();
	
		// check for entropy and relay coexist error in user-defined functions
		for (auto &itor : m_forwardDeclaredFunctions)
		{
			if (itor.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType)
			{
				const transpiler::FunctionSignature &signature = itor.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[itor.declaredFunc.overloadIndex];

				if (itor.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->outerType->typeCategory == transpiler::ConcreteType::ContractType)
				{
					m_errorPortal.SetAnchor(itor.ctx->functionDeclaration()->identifier()->start);
					ReservedFunctions_PostFlagPropagate(itor.ctx->functionDeclaration()->identifier()->getText(), signature);
				}
			}
		}

		// check for entropy and relay coexist error in relay lambda functions
		for (size_t i = 0; i < m_pendingRelayLambdas.size(); i++)
		{
			transpiler::FunctionRef &func = m_exportedFunctions[m_pendingRelayLambdas[i].exportFuncSlot];
			if (func.functionIdentifier != nullptr && func.functionIdentifier->qualifiedType.baseConcreteType != nullptr && func.functionIdentifier->qualifiedType.baseConcreteType->typeCategory == transpiler::ConcreteType::FunctionType)
			{
				const transpiler::FunctionSignature &signature = func.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[func.overloadIndex];

				if (func.functionIdentifier->qualifiedType.baseConcreteType->outerType->typeCategory == transpiler::ConcreteType::ContractType)
				{
					m_errorPortal.SetAnchor(m_pendingRelayLambdas[i].pDefinitionCtx->start);
					ReservedFunctions_PostFlagPropagate(func.functionIdentifier->inputName, signature);
				}
			}
		}

		VerifyImplementedInterface(ctx->interfaceRef());

		if (m_errorPortal.m_errors.size() == 0)
		{
			codeSerializer.PopIndent();
			codeSerializer.AddLine("};");

			GenerateAuxiliaryFunctions();
			GenerateExportFunctionMeta();
			GenerateExportInterface();
		}
	}
}

void PredaRealListener::enterFunctionDefinition(PredaParser::FunctionDefinitionContext *ctx)
{
	ConcreteTypePtr thisType = m_transpilerCtx.thisPtrStack.stack.back().thisType;

	// global function definition is not supported yet, hence this should hold
	assert(thisType != nullptr);

	if (thisType == nullptr)
		thisType = m_transpilerCtx.globalType;

	m_transpilerCtx.functionCtx.PushFunctionScope(thisType->CreateInnerUnnamedScopeType("function_" + ctx->functionDeclaration()->identifier()->getText()));

	auto itor = m_functionDefinitionContext2ForwardDeclaredFunctions.find(ctx);
	if (itor == m_functionDefinitionContext2ForwardDeclaredFunctions.end())			// forward declaration failed
		return;
		
	ForwardDeclaredContractFunction &forwardDeclaredFunc = m_forwardDeclaredFunctions[itor->second];
	transpiler::FunctionSignature functionSignature = forwardDeclaredFunc.declaredFunc.functionIdentifier->qualifiedType.baseConcreteType->vOverloadedFunctions[forwardDeclaredFunc.declaredFunc.overloadIndex];

	m_transpilerCtx.functionCtx.functionRef = forwardDeclaredFunc.declaredFunc;

	m_transpilerCtx.thisPtrStack.Push(thisType, (functionSignature.flags & uint32_t(transpiler::FunctionFlags::IsConst)) != 0);

	//parameters
	std::vector<PredaParser::FunctionParameterContext *> vParamCtx = ctx->functionDeclaration()->functionParameterList()->functionParameter();
	for (size_t i = 0; i < vParamCtx.size(); i++)
	{
		// function parameters are defined in the current scope (function scope)
		bool bIsConst = (vParamCtx[i]->ConstantKeyword() != nullptr);
		ConcreteTypePtr pType = m_identifierHub.GetTypeFromTypeNameContext(vParamCtx[i]->typeName());
		if (pType == nullptr)
			return;

		// Although we already checked this at forward declaration, defining the parameter in local scope could still fail. Because another identifier with the same name could be declared in the outer scope after the definition of this function
		if (DefineFunctionLocalVariable(pType, vParamCtx[i]->identifier(), bIsConst, 0) == nullptr)
			return;

		// Here there's no need to check parameter const qualifier for transaction and relay functions, it's already done at forward declaration
	}

	m_lastStatementInFunctionIsReturnStatement = false;

	{
		std::string line;
		if (functionSignature.returnType.baseConcreteType == nullptr)
		{
			line += "void";
		}
		else
		{
			if (functionSignature.returnType.bIsConst)
				line += "const ";
			line += functionSignature.returnType.baseConcreteType->outputFullName;
		}
		line += " " + forwardDeclaredFunc.declaredFunc.functionIdentifier->outputName + "(";
		for (size_t i = 0; i < functionSignature.parameters.size(); i++)
		{
			if (i > 0)
				line += ", ";
			if (functionSignature.parameters[i]->qualifiedType.bIsConst)
				line += "const ";
			line += functionSignature.parameters[i]->qualifiedType.baseConcreteType->outputFullName + " " + functionSignature.parameters[i]->outputName;
		}
		line += ")";
		if ((functionSignature.flags & uint32_t(transpiler::FunctionFlags::IsConst)) != 0)
			line += " const";
		line += " { prlrt::burn_gas_function_call();";
		codeSerializer.AddLine(line);
		codeSerializer.PushIndent();
	}
}

void PredaRealListener::exitFunctionDefinition(PredaParser::FunctionDefinitionContext *ctx)
{
	assert(m_transpilerCtx.functionCtx.localScopes.size() == 1);

	AUTO_POP_FUNCTION_CONTEXT_LOCAL_SCOPE_STACK;

	// This could happen if the function failed forward declaration
	if (m_transpilerCtx.functionCtx.GetFunctionSignature() == nullptr)
		return;

	AUTO_POP_THIS_PTR_STACK;

	// If a function should return a value but is not
	// TODO: Check in a more sophisticated way: e.g. when both if-else block returns at the end, recognize that and do not throw an error
	if (m_transpilerCtx.functionCtx.GetFunctionSignature()->returnType.baseConcreteType != nullptr && !m_lastStatementInFunctionIsReturnStatement)
	{
		m_errorPortal.SetAnchor(ctx->stop);
		m_errorPortal.AddNoReturnFromFunctionWithReturnTypeError();
		return;
	}

	codeSerializer.PopIndent();
	codeSerializer.AddLine("}");
}

ConcreteTypePtr PredaRealListener::GetTypeFromExportedTypeNameStrStream(std::stringstream &inoutStream)
{
	std::string baseTypeName;
	if (!(inoutStream >> baseTypeName))
		return nullptr;
	if (baseTypeName == "array")
	{
		ConcreteTypePtr elementType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (elementType == nullptr)
			return nullptr;
		std::vector<ConcreteTypePtr> templateParams(1, elementType);
		return m_transpilerCtx.GetBuiltInArrayType()->GetConcreteTypeFromTemplateParams(templateParams);
	}
	else if (baseTypeName == "map")
	{
		ConcreteTypePtr keyType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (keyType == nullptr)
			return nullptr;
		ConcreteTypePtr elementType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (elementType == nullptr)
			return nullptr;
		std::vector<ConcreteTypePtr> templateParams = { keyType, elementType };
		return m_transpilerCtx.GetBuiltInMapType()->GetConcreteTypeFromTemplateParams(templateParams);
	}
	else if (baseTypeName == "scattered_map")
	{
		ConcreteTypePtr keyType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (keyType == nullptr)
			return nullptr;
		ConcreteTypePtr elementType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (elementType == nullptr)
			return nullptr;
		std::vector<ConcreteTypePtr> templateParams = { keyType, elementType };
		ConcreteTypePtr retType = m_transpilerCtx.GetBuiltInScatteredMapType()->GetConcreteTypeFromTemplateParams(templateParams);
		retType->supportedOperatorMask &= (~uint64_t(transpiler::OperatorTypeBitMask::AssignmentBit));
		return retType;
	}
	if (baseTypeName == "scattered_array")
	{
		ConcreteTypePtr elementType = GetTypeFromExportedTypeNameStrStream(inoutStream);
		if (elementType == nullptr)
			return nullptr;
		std::vector<ConcreteTypePtr> templateParams(1, elementType);
		ConcreteTypePtr retType = m_transpilerCtx.GetBuiltInScatteredArrayType()->GetConcreteTypeFromTemplateParams(templateParams);
		retType->supportedOperatorMask &= (~uint64_t(transpiler::OperatorTypeBitMask::AssignmentBit));
		return retType;
	}
	else
	{
		size_t scopePos = baseTypeName.rfind(".");
		if (scopePos == std::string::npos)
			return m_transpilerCtx.globalType->FindInnerConcreteType(baseTypeName);

		std::string nonScopedTypeName = baseTypeName.substr(scopePos + 1);
		std::string contractFullName = baseTypeName.substr(0, scopePos);
		auto it = m_contractFullNameToImportName.find(contractFullName);
		if (it == m_contractFullNameToImportName.end())
			return nullptr;
		std::string contractAlias = it->second;
		ConcreteTypePtr contractType = m_transpilerCtx.globalType->FindInnerConcreteType(contractAlias);
		if (contractType == nullptr)
			return nullptr;
		ConcreteTypePtr ret = contractType->FindInnerConcreteType(nonScopedTypeName);
		if (ret == nullptr)
			return nullptr;

		return ret;
	}

	return nullptr;
}

ConcreteTypePtr PredaRealListener::GetTypeFromExportedTypeName(const char *typeName)
{
	std::stringstream inTypeNameStream(typeName);
	return GetTypeFromExportedTypeNameStrStream(inTypeNameStream);
}

ConcreteTypePtr PredaRealListener::ScopeTypeToConcreteType(transpiler::ScopeType scope)
{
	switch (scope)
	{
	case transpiler::ScopeType::Address:
		return m_transpilerCtx.GetBuiltInAddressType();
	case transpiler::ScopeType::Uint32:
		return m_transpilerCtx.GetBuiltInIntegerType(32, false);
	case transpiler::ScopeType::Uint64:
		return m_transpilerCtx.GetBuiltInIntegerType(64, false);
	case transpiler::ScopeType::Uint96:
		return nullptr;								// uint96 / 160 scopes are not supported yet because there's no corresponding uint types yet
	case transpiler::ScopeType::Uint128:
		return m_transpilerCtx.GetBuiltInIntegerType(128, false);
	case transpiler::ScopeType::Uint160:
		return nullptr;								// uint96 / 160 scopes are not supported yet because there's no corresponding uint types yet
	case transpiler::ScopeType::Uint256:
		return m_transpilerCtx.GetBuiltInIntegerType(256, false);
	case transpiler::ScopeType::Uint512:
		return m_transpilerCtx.GetBuiltInIntegerType(512, false);
	default:
		return nullptr;
	}
	return nullptr;
}

transpiler::ScopeType PredaRealListener::ConcreteTypeToScopeType(ConcreteTypePtr type)
{
	if (type == m_transpilerCtx.GetBuiltInAddressType())
		return transpiler::ScopeType::Address;
	else if (type == m_transpilerCtx.GetBuiltInIntegerType(32, false))
		return transpiler::ScopeType::Uint32;
	else if (type == m_transpilerCtx.GetBuiltInIntegerType(64, false))
		return transpiler::ScopeType::Uint64;
	else if (type == m_transpilerCtx.GetBuiltInIntegerType(128, false))
		return transpiler::ScopeType::Uint128;
	else if (type == m_transpilerCtx.GetBuiltInIntegerType(256, false))
		return transpiler::ScopeType::Uint256;
	else if (type == m_transpilerCtx.GetBuiltInIntegerType(512, false))
		return transpiler::ScopeType::Uint512;

	// uint96 / 160 scopes are not supported yet because there's no corresponding uint types yet

	return transpiler::ScopeType::None;
}

void PredaPreCompileListener::enterPredaSource(PredaParser::PredaSourceContext *ctx)
{
	m_currentContractName = ctx->contractDefinition()->identifier()->getText();
	if(ctx->directive().size()){
		std::vector<PredaParser::DirectiveContext *> directive_vec = ctx->directive();
		for(auto it : directive_vec){
			if(it->importDirective())
				ProcessImportDirective(it->importDirective());
		}
	}
}

bool PredaPreCompileListener::ProcessImportDirective(const PredaParser::ImportDirectiveContext *ctx){
	std::string contractFullName;
	if (ctx->dAppName)
	{
		contractFullName = ctx->dAppName->getText() + "." + ctx->contractName->getText();
	}
	else
	{
		contractFullName = m_currentDAppName + "." + ctx->contractName->getText();
	}
	m_dependentContracts.push_back(contractFullName);
	return true;
}

